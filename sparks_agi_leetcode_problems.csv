Task_ID,Question_Content,Difficulty
2432,"There are n employees, each with a unique id from 0 to n - 1.  You are given a 2D integer array logs where logs[i] = [idi, leaveTimei] where:  idi is the id of the employee that worked on the ith task, and leaveTimei is the time at which the employee finished the ith task. All the values leaveTimei are unique. Note that the ith task starts the moment right after the (i - 1)th task ends, and the 0th task starts at time 0.  Return the id of the employee that worked the task with the longest time. If there is a tie between two or more employees, return the smallest id among them.     Example 1:  Input: n = 10, logs = [[0,3],[2,5],[0,9],[1,15]] Output: 1 Explanation:  Task 0 started at 0 and ended at 3 with 3 units of times. Task 1 started at 3 and ended at 5 with 2 units of times. Task 2 started at 5 and ended at 9 with 4 units of times. Task 3 started at 9 and ended at 15 with 6 units of times. The task with the longest time is task 3 and the employee with id 1 is the one that worked on it, so we return 1. Example 2:  Input: n = 26, logs = [[1,1],[3,7],[2,12],[7,17]] Output: 3 Explanation:  Task 0 started at 0 and ended at 1 with 1 unit of times. Task 1 started at 1 and ended at 7 with 6 units of times. Task 2 started at 7 and ended at 12 with 5 units of times. Task 3 started at 12 and ended at 17 with 5 units of times. The tasks with the longest time is task 1. The employee that worked on it is 3, so we return 3. Example 3:  Input: n = 2, logs = [[0,10],[1,20]] Output: 0 Explanation:  Task 0 started at 0 and ended at 10 with 10 units of times. Task 1 started at 10 and ended at 20 with 10 units of times. The tasks with the longest time are tasks 0 and 1. The employees that worked on them are 0 and 1, so we return the smallest id 0.    Constraints:  2 <= n <= 500 1 <= logs.length <= 500 logs[i].length == 2 0 <= idi <= n - 1 1 <= leaveTimei <= 500 idi != idi+1 leaveTimei are sorted in a strictly increasing order.", Easy
2433,"You are given an integer array pref of size n. Find and return the array arr of size n that satisfies:  pref[i] = arr[0] ^ arr[1] ^ ... ^ arr[i]. Note that ^ denotes the bitwise-xor operation.  It can be proven that the answer is unique.     Example 1:  Input: pref = [5,2,0,3,1] Output: [5,7,2,3,2] Explanation: From the array [5,7,2,3,2] we have the following: - pref[0] = 5. - pref[1] = 5 ^ 7 = 2. - pref[2] = 5 ^ 7 ^ 2 = 0. - pref[3] = 5 ^ 7 ^ 2 ^ 3 = 3. - pref[4] = 5 ^ 7 ^ 2 ^ 3 ^ 2 = 1. Example 2:  Input: pref = [13] Output: [13] Explanation: We have pref[0] = arr[0] = 13.    Constraints:  1 <= pref.length <= 105 0 <= pref[i] <= 106", Medium
2434,"You are given a string s and a robot that currently holds an empty string t. Apply one of the following operations until s and t are both empty:  Remove the first character of a string s and give it to the robot. The robot will append this character to the string t. Remove the last character of a string t and give it to the robot. The robot will write this character on paper. Return the lexicographically smallest string that can be written on the paper.     Example 1:  Input: s = ""zza"" Output: ""azz"" Explanation: Let p denote the written string. Initially p="", s=""zza"", t="". Perform first operation three times p="", s="", t=""zza"". Perform second operation three times p=""azz"", s="", t="". Example 2:  Input: s = ""bac"" Output: ""abc"" Explanation: Let p denote the written string. Perform first operation twice p="", s=""c"", t=""ba"".  Perform second operation twice p=""ab"", s=""c"", t="".  Perform first operation p=""ab"", s="", t=""c"".  Perform second operation p=""abc"", s="", t="". Example 3:  Input: s = ""bdda"" Output: ""addb"" Explanation: Let p denote the written string. Initially p="", s=""bdda"", t="". Perform first operation four times p="", s="", t=""bdda"". Perform second operation four times p=""addb"", s="", t="".    Constraints:  1 <= s.length <= 105 s consists of only English lowercase letters.", Medium
2435,"You are given a 0-indexed m x n integer matrix grid and an integer k. You are currently at position (0, 0) and you want to reach position (m - 1, n - 1) moving only down or right.  Return the number of paths where the sum of the elements on the path is divisible by k. Since the answer may be very large, return it modulo 109 + 7.     Example 1:   Input: grid = [[5,2,4],[3,0,5],[0,7,2]], k = 3 Output: 2 Explanation: There are two paths where the sum of the elements on the path is divisible by k. The first path highlighted in red has a sum of 5 + 2 + 4 + 5 + 2 = 18 which is divisible by 3. The second path highlighted in blue has a sum of 5 + 3 + 0 + 5 + 2 = 15 which is divisible by 3. Example 2:   Input: grid = [[0,0]], k = 5 Output: 1 Explanation: The path highlighted in red has a sum of 0 + 0 = 0 which is divisible by 5. Example 3:   Input: grid = [[7,3,4,9],[2,3,6,2],[2,3,7,0]], k = 1 Output: 10 Explanation: Every integer is divisible by 1 so the sum of the elements on every possible path is divisible by k.    Constraints:  m == grid.length n == grid[i].length 1 <= m, n <= 5 * 104 1 <= m * n <= 5 * 104 0 <= grid[i][j] <= 100 1 <= k <= 50", Hard
2437,"You are given a string of length 5 called time, representing the current time on a digital clock in the format ""hh:mm"". The earliest possible time is ""00:00"" and the latest possible time is ""23:59"".  In the string time, the digits represented by the ? symbol are unknown, and must be replaced with a digit from 0 to 9.  Return an integer answer, the number of valid clock times that can be created by replacing every ? with a digit from 0 to 9.     Example 1:  Input: time = ""?5:00"" Output: 2 Explanation: We can replace the ? with either a 0 or 1, producing ""05:00"" or ""15:00"". Note that we cannot replace it with a 2, since the time ""25:00"" is invalid. In total, we have two choices. Example 2:  Input: time = ""0?:0?"" Output: 100 Explanation: Each ? can be replaced by any digit from 0 to 9, so we have 100 total choices. Example 3:  Input: time = ""??:??"" Output: 1440 Explanation: There are 24 possible choices for the hours, and 60 possible choices for the minutes. In total, we have 24 * 60 = 1440 choices.    Constraints:  time is a valid string of length 5 in the format ""hh:mm"". ""00"" <= hh <= ""23"" ""00"" <= mm <= ""59"" Some of the digits might be replaced with '?' and need to be replaced with digits from 0 to 9.", Easy
2438,"Given a positive integer n, there exists a 0-indexed array called powers, composed of the minimum number of powers of 2 that sum to n. The array is sorted in non-decreasing order, and there is only one way to form the array.  You are also given a 0-indexed 2D integer array queries, where queries[i] = [lefti, righti]. Each queries[i] represents a query where you have to find the product of all powers[j] with lefti <= j <= righti.  Return an array answers, equal in length to queries, where answers[i] is the answer to the ith query. Since the answer to the ith query may be too large, each answers[i] should be returned modulo 109 + 7.     Example 1:  Input: n = 15, queries = [[0,1],[2,2],[0,3]] Output: [2,4,64] Explanation: For n = 15, powers = [1,2,4,8]. It can be shown that powers cannot be a smaller size. Answer to 1st query: powers[0] * powers[1] = 1 * 2 = 2. Answer to 2nd query: powers[2] = 4. Answer to 3rd query: powers[0] * powers[1] * powers[2] * powers[3] = 1 * 2 * 4 * 8 = 64. Each answer modulo 109 + 7 yields the same answer, so [2,4,64] is returned. Example 2:  Input: n = 2, queries = [[0,0]] Output: [2] Explanation: For n = 2, powers = [2]. The answer to the only query is powers[0] = 2. The answer modulo 109 + 7 is the same, so [2] is returned.    Constraints:  1 <= n <= 109 1 <= queries.length <= 105 0 <= starti <= endi < powers.length", Medium
2439,"You are given a 0-indexed array nums comprising of n non-negative integers.  In one operation, you must:  Choose an integer i such that 1 <= i < n and nums[i] > 0. Decrease nums[i] by 1. Increase nums[i - 1] by 1. Return the minimum possible value of the maximum integer of nums after performing any number of operations.     Example 1:  Input: nums = [3,7,1,6] Output: 5 Explanation: One set of optimal operations is as follows: 1. Choose i = 1, and nums becomes [4,6,1,6]. 2. Choose i = 3, and nums becomes [4,6,2,5]. 3. Choose i = 1, and nums becomes [5,5,2,5]. The maximum integer of nums is 5. It can be shown that the maximum number cannot be less than 5. Therefore, we return 5. Example 2:  Input: nums = [10,1] Output: 10 Explanation: It is optimal to leave nums as is, and since 10 is the maximum value, we return 10.    Constraints:  n == nums.length 2 <= n <= 105 0 <= nums[i] <= 109", Medium
2440,"There is an undirected tree with n nodes labeled from 0 to n - 1.  You are given a 0-indexed integer array nums of length n where nums[i] represents the value of the ith node. You are also given a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.  You are allowed to delete some edges, splitting the tree into multiple connected components. Let the value of a component be the sum of all nums[i] for which node i is in the component.  Return the maximum number of edges you can delete, such that every connected component in the tree has the same value.     Example 1:   Input: nums = [6,2,2,2,6], edges = [[0,1],[1,2],[1,3],[3,4]]  Output: 2  Explanation: The above figure shows how we can delete the edges [0,1] and [3,4]. The created components are nodes [0], [1,2,3] and [4]. The sum of the values in each component equals 6. It can be proven that no better deletion exists, so the answer is 2. Example 2:  Input: nums = [2], edges = [] Output: 0 Explanation: There are no edges to be deleted.    Constraints:  1 <= n <= 2 * 104 nums.length == n 1 <= nums[i] <= 50 edges.length == n - 1 edges[i].length == 2 0 <= edges[i][0], edges[i][1] <= n - 1 edges represents a valid tree.", Hard
2441,"Given an integer array nums that does not contain any zeros, find the largest positive integer k such that -k also exists in the array.  Return the positive integer k. If there is no such integer, return -1.     Example 1:  Input: nums = [-1,2,-3,3] Output: 3 Explanation: 3 is the only valid k we can find in the array. Example 2:  Input: nums = [-1,10,6,7,-7,1] Output: 7 Explanation: Both 1 and 7 have their corresponding negative values in the array. 7 has a larger value. Example 3:  Input: nums = [-10,8,6,7,-2,-3] Output: -1 Explanation: There is no a single valid k, we return -1.    Constraints:  1 <= nums.length <= 1000 -1000 <= nums[i] <= 1000 nums[i] != 0", Easy
2442,"You are given an array nums consisting of positive integers.  You have to take each integer in the array, reverse its digits, and add it to the end of the array. You should apply this operation to the original integers in nums.  Return the number of distinct integers in the final array.     Example 1:  Input: nums = [1,13,10,12,31] Output: 6 Explanation: After including the reverse of each number, the resulting array is [1,13,10,12,31,1,31,1,21,13]. The reversed integers that were added to the end of the array are underlined. Note that for the integer 10, after reversing it, it becomes 01 which is just 1. The number of distinct integers in this array is 6 (The numbers 1, 10, 12, 13, 21, and 31). Example 2:  Input: nums = [2,2,2] Output: 1 Explanation: After including the reverse of each number, the resulting array is [2,2,2,2,2,2]. The number of distinct integers in this array is 1 (The number 2).    Constraints:  1 <= nums.length <= 105 1 <= nums[i] <= 106", Medium
2443,"Given a non-negative integer num, return true if num can be expressed as the sum of any non-negative integer and its reverse, or false otherwise.     Example 1:  Input: num = 443 Output: true Explanation: 172 + 271 = 443 so we return true. Example 2:  Input: num = 63 Output: false Explanation: 63 cannot be expressed as the sum of a non-negative integer and its reverse so we return false. Example 3:  Input: num = 181 Output: true Explanation: 140 + 041 = 181 so we return true. Note that when a number is reversed, there may be leading zeros.    Constraints:  0 <= num <= 105", Medium
2444,"You are given an integer array nums and two integers minK and maxK.  A fixed-bound subarray of nums is a subarray that satisfies the following conditions:  The minimum value in the subarray is equal to minK. The maximum value in the subarray is equal to maxK. Return the number of fixed-bound subarrays.  A subarray is a contiguous part of an array.     Example 1:  Input: nums = [1,3,5,2,7,5], minK = 1, maxK = 5 Output: 2 Explanation: The fixed-bound subarrays are [1,3,5] and [1,3,5,2]. Example 2:  Input: nums = [1,1,1,1], minK = 1, maxK = 1 Output: 10 Explanation: Every subarray of nums is a fixed-bound subarray. There are 10 possible subarrays.    Constraints:  2 <= nums.length <= 105 1 <= nums[i], minK, maxK <= 106", Hard
2446,"You are given two arrays of strings that represent two inclusive events that happened on the same day, event1 and event2, where:  event1 = [startTime1, endTime1] and event2 = [startTime2, endTime2]. Event times are valid 24 hours format in the form of HH:MM.  A conflict happens when two events have some non-empty intersection (i.e., some moment is common to both events).  Return true if there is a conflict between two events. Otherwise, return false.     Example 1:  Input: event1 = [""01:15"",""02:00""], event2 = [""02:00"",""03:00""] Output: true Explanation: The two events intersect at time 2:00. Example 2:  Input: event1 = [""01:00"",""02:00""], event2 = [""01:20"",""03:00""] Output: true Explanation: The two events intersect starting from 01:20 to 02:00. Example 3:  Input: event1 = [""10:00"",""11:00""], event2 = [""14:00"",""15:00""] Output: false Explanation: The two events do not intersect.    Constraints:  evnet1.length == event2.length == 2. event1[i].length == event2[i].length == 5 startTime1 <= endTime1 startTime2 <= endTime2 All the event times follow the HH:MM format.", Easy
2447,"Given an integer array nums and an integer k, return the number of subarrays of nums where the greatest common divisor of the subarray's elements is k.  A subarray is a contiguous non-empty sequence of elements within an array.  The greatest common divisor of an array is the largest integer that evenly divides all the array elements.     Example 1:  Input: nums = [9,3,1,2,6,3], k = 3 Output: 4 Explanation: The subarrays of nums where 3 is the greatest common divisor of all the subarray's elements are: - [9,3,1,2,6,3] - [9,3,1,2,6,3] - [9,3,1,2,6,3] - [9,3,1,2,6,3] Example 2:  Input: nums = [4], k = 7 Output: 0 Explanation: There are no subarrays of nums where 7 is the greatest common divisor of all the subarray's elements.    Constraints:  1 <= nums.length <= 1000 1 <= nums[i], k <= 109", Medium
2448,"You are given two 0-indexed arrays nums and cost consisting each of n positive integers.  You can do the following operation any number of times:  Increase or decrease any element of the array nums by 1. The cost of doing one operation on the ith element is cost[i].  Return the minimum total cost such that all the elements of the array nums become equal.     Example 1:  Input: nums = [1,3,5,2], cost = [2,3,1,14] Output: 8 Explanation: We can make all the elements equal to 2 in the following way: - Increase the 0th element one time. The cost is 2. - Decrease the 1st element one time. The cost is 3. - Decrease the 2nd element three times. The cost is 1 + 1 + 1 = 3. The total cost is 2 + 3 + 3 = 8. It can be shown that we cannot make the array equal with a smaller cost. Example 2:  Input: nums = [2,2,2,2,2], cost = [4,2,8,1,3] Output: 0 Explanation: All the elements are already equal, so no operations are needed.    Constraints:  n == nums.length == cost.length 1 <= n <= 105 1 <= nums[i], cost[i] <= 106 Test cases are generated in a way that the output doesn't exceed 253-1", Hard
2449,"You are given two positive integer arrays nums and target, of the same length.  In one operation, you can choose any two distinct indices i and j where 0 <= i, j < nums.length and:  set nums[i] = nums[i] + 2 and set nums[j] = nums[j] - 2. Two arrays are considered to be similar if the frequency of each element is the same.  Return the minimum number of operations required to make nums similar to target. The test cases are generated such that nums can always be similar to target.     Example 1:  Input: nums = [8,12,6], target = [2,14,10] Output: 2 Explanation: It is possible to make nums similar to target in two operations: - Choose i = 0 and j = 2, nums = [10,12,4]. - Choose i = 1 and j = 2, nums = [10,14,2]. It can be shown that 2 is the minimum number of operations needed. Example 2:  Input: nums = [1,2,5], target = [4,1,3] Output: 1 Explanation: We can make nums similar to target in one operation: - Choose i = 1 and j = 2, nums = [1,4,3]. Example 3:  Input: nums = [1,1,1,1,1], target = [1,1,1,1,1] Output: 0 Explanation: The array nums is already similiar to target.    Constraints:  n == nums.length == target.length 1 <= n <= 105 1 <= nums[i], target[i] <= 106 It is possible to make nums similar to target.", Hard
2451,"You are given an array of equal-length strings words. Assume that the length of each string is n.  Each string words[i] can be converted into a difference integer array difference[i] of length n - 1 where difference[i][j] = words[i][j+1] - words[i][j] where 0 <= j <= n - 2. Note that the difference between two letters is the difference between their positions in the alphabet i.e. the position of 'a' is 0, 'b' is 1, and 'z' is 25.  For example, for the string ""acb"", the difference integer array is [2 - 0, 1 - 2] = [2, -1]. All the strings in words have the same difference integer array, except one. You should find that string.  Return the string in words that has different difference integer array.     Example 1:  Input: words = [""adc"",""wzy"",""abc""] Output: ""abc"" Explanation:  - The difference integer array of ""adc"" is [3 - 0, 2 - 3] = [3, -1]. - The difference integer array of ""wzy"" is [25 - 22, 24 - 25]= [3, -1]. - The difference integer array of ""abc"" is [1 - 0, 2 - 1] = [1, 1].  The odd array out is [1, 1], so we return the corresponding string, ""abc"". Example 2:  Input: words = [""aaa"",""bob"",""ccc"",""ddd""] Output: ""bob"" Explanation: All the integer arrays are [0, 0] except for ""bob"", which corresponds to [13, -13].    Constraints:  3 <= words.length <= 100 n == words[i].length 2 <= n <= 20 words[i] consists of lowercase English letters.", Easy
2452,"You are given two string arrays, queries and dictionary. All words in each array comprise of lowercase English letters and have the same length.  In one edit you can take a word from queries, and change any letter in it to any other letter. Find all words from queries that, after a maximum of two edits, equal some word from dictionary.  Return a list of all words from queries, that match with some word from dictionary after a maximum of two edits. Return the words in the same order they appear in queries.     Example 1:  Input: queries = [""word"",""note"",""ants"",""wood""], dictionary = [""wood"",""joke"",""moat""] Output: [""word"",""note"",""wood""] Explanation: - Changing the 'r' in ""word"" to 'o' allows it to equal the dictionary word ""wood"". - Changing the 'n' to 'j' and the 't' to 'k' in ""note"" changes it to ""joke"". - It would take more than 2 edits for ""ants"" to equal a dictionary word. - ""wood"" can remain unchanged (0 edits) and match the corresponding dictionary word. Thus, we return [""word"",""note"",""wood""]. Example 2:  Input: queries = [""yes""], dictionary = [""not""] Output: [] Explanation: Applying any two edits to ""yes"" cannot make it equal to ""not"". Thus, we return an empty array.    Constraints:  1 <= queries.length, dictionary.length <= 100 n == queries[i].length == dictionary[j].length 1 <= n <= 100 All queries[i] and dictionary[j] are composed of lowercase English letters.", Medium
2453,"You are given a 0-indexed array nums consisting of positive integers, representing targets on a number line. You are also given an integer space.  You have a machine which can destroy targets. Seeding the machine with some nums[i] allows it to destroy all targets with values that can be represented as nums[i] + c * space, where c is any non-negative integer. You want to destroy the maximum number of targets in nums.  Return the minimum value of nums[i] you can seed the machine with to destroy the maximum number of targets.     Example 1:  Input: nums = [3,7,8,1,1,5], space = 2 Output: 1 Explanation: If we seed the machine with nums[3], then we destroy all targets equal to 1,3,5,7,9,...  In this case, we would destroy 5 total targets (all except for nums[2]).  It is impossible to destroy more than 5 targets, so we return nums[3]. Example 2:  Input: nums = [1,3,5,2,4,6], space = 2 Output: 1 Explanation: Seeding the machine with nums[0], or nums[3] destroys 3 targets.  It is not possible to destroy more than 3 targets. Since nums[0] is the minimal integer that can destroy 3 targets, we return 1. Example 3:  Input: nums = [6,2,5], space = 100 Output: 2 Explanation: Whatever initial seed we select, we can only destroy 1 target. The minimal seed is nums[1].    Constraints:  1 <= nums.length <= 105 1 <= nums[i] <= 109 1 <= space <= 109", Medium
2454,"You are given a 0-indexed array of non-negative integers nums. For each integer in nums, you must find its respective second greater integer.  The second greater integer of nums[i] is nums[j] such that:  j > i nums[j] > nums[i] There exists exactly one index k such that nums[k] > nums[i] and i < k < j. If there is no such nums[j], the second greater integer is considered to be -1.  For example, in the array [1, 2, 4, 3], the second greater integer of 1 is 4, 2 is 3, and that of 3 and 4 is -1. Return an integer array answer, where answer[i] is the second greater integer of nums[i].     Example 1:  Input: nums = [2,4,0,9,6] Output: [9,6,6,-1,-1] Explanation: 0th index: 4 is the first integer greater than 2, and 9 is the second integer greater than 2, to the right of 2. 1st index: 9 is the first, and 6 is the second integer greater than 4, to the right of 4. 2nd index: 9 is the first, and 6 is the second integer greater than 0, to the right of 0. 3rd index: There is no integer greater than 9 to its right, so the second greater integer is considered to be -1. 4th index: There is no integer greater than 6 to its right, so the second greater integer is considered to be -1. Thus, we return [9,6,6,-1,-1]. Example 2:  Input: nums = [3,3] Output: [-1,-1] Explanation: We return [-1,-1] since neither integer has any integer greater than it.    Constraints:  1 <= nums.length <= 105 0 <= nums[i] <= 109", Hard
2455,"Given an integer array nums of positive integers, return the average value of all even integers that are divisible by 3.  Note that the average of n elements is the sum of the n elements divided by n and rounded down to the nearest integer.     Example 1:  Input: nums = [1,3,6,10,12,15] Output: 9 Explanation: 6 and 12 are even numbers that are divisible by 3. (6 + 12) / 2 = 9. Example 2:  Input: nums = [1,2,4,7,10] Output: 0 Explanation: There is no single number that satisfies the requirement, so return 0.    Constraints:  1 <= nums.length <= 1000 1 <= nums[i] <= 1000", Easy
2456,"You are given two string arrays creators and ids, and an integer array views, all of length n. The ith video on a platform was created by creator[i], has an id of ids[i], and has views[i] views.  The popularity of a creator is the sum of the number of views on all of the creator's videos. Find the creator with the highest popularity and the id of their most viewed video.  If multiple creators have the highest popularity, find all of them. If multiple videos have the highest view count for a creator, find the lexicographically smallest id. Return a 2D array of strings answer where answer[i] = [creatori, idi] means that creatori has the highest popularity and idi is the id of their most popular video. The answer can be returned in any order.     Example 1:  Input: creators = [""alice"",""bob"",""alice"",""chris""], ids = [""one"",""two"",""three"",""four""], views = [5,10,5,4] Output: [[""alice"",""one""],[""bob"",""two""]] Explanation: The popularity of alice is 5 + 5 = 10. The popularity of bob is 10. The popularity of chris is 4. alice and bob are the most popular creators. For bob, the video with the highest view count is ""two"". For alice, the videos with the highest view count are ""one"" and ""three"". Since ""one"" is lexicographically smaller than ""three"", it is included in the answer. Example 2:  Input: creators = [""alice"",""alice"",""alice""], ids = [""a"",""b"",""c""], views = [1,2,2] Output: [[""alice"",""b""]] Explanation: The videos with id ""b"" and ""c"" have the highest view count. Since ""b"" is lexicographically smaller than ""c"", it is included in the answer.    Constraints:  n == creators.length == ids.length == views.length 1 <= n <= 105 1 <= creators[i].length, ids[i].length <= 5 creators[i] and ids[i] consist only of lowercase English letters. 0 <= views[i] <= 105", Medium
2457,"You are given two positive integers n and target.  An integer is considered beautiful if the sum of its digits is less than or equal to target.  Return the minimum non-negative integer x such that n + x is beautiful. The input will be generated such that it is always possible to make n beautiful.     Example 1:  Input: n = 16, target = 6 Output: 4 Explanation: Initially n is 16 and its digit sum is 1 + 6 = 7. After adding 4, n becomes 20 and digit sum becomes 2 + 0 = 2. It can be shown that we can not make n beautiful with adding non-negative integer less than 4. Example 2:  Input: n = 467, target = 6 Output: 33 Explanation: Initially n is 467 and its digit sum is 4 + 6 + 7 = 17. After adding 33, n becomes 500 and digit sum becomes 5 + 0 + 0 = 5. It can be shown that we can not make n beautiful with adding non-negative integer less than 33. Example 3:  Input: n = 1, target = 1 Output: 0 Explanation: Initially n is 1 and its digit sum is 1, which is already smaller than or equal to target.    Constraints:  1 <= n <= 1012 1 <= target <= 150 The input will be generated such that it is always possible to make n beautiful.", Medium
2458,"You are given the root of a binary tree with n nodes. Each node is assigned a unique value from 1 to n. You are also given an array queries of size m.  You have to perform m independent queries on the tree where in the ith query you do the following:  Remove the subtree rooted at the node with the value queries[i] from the tree. It is guaranteed that queries[i] will not be equal to the value of the root. Return an array answer of size m where answer[i] is the height of the tree after performing the ith query.  Note:  The queries are independent, so the tree returns to its initial state after each query. The height of a tree is the number of edges in the longest simple path from the root to some node in the tree.    Example 1:   Input: root = [1,3,4,2,null,6,5,null,null,null,null,null,7], queries = [4] Output: [2] Explanation: The diagram above shows the tree after removing the subtree rooted at node with value 4. The height of the tree is 2 (The path 1 -> 3 -> 2). Example 2:   Input: root = [5,8,9,2,1,3,7,4,6], queries = [3,2,4,8] Output: [3,2,3,2] Explanation: We have the following queries: - Removing the subtree rooted at node with value 3. The height of the tree becomes 3 (The path 5 -> 8 -> 2 -> 4). - Removing the subtree rooted at node with value 2. The height of the tree becomes 2 (The path 5 -> 8 -> 1). - Removing the subtree rooted at node with value 4. The height of the tree becomes 3 (The path 5 -> 8 -> 2 -> 6). - Removing the subtree rooted at node with value 8. The height of the tree becomes 2 (The path 5 -> 9 -> 3).    Constraints:  The number of nodes in the tree is n. 2 <= n <= 105 1 <= Node.val <= n All the values in the tree are unique. m == queries.length 1 <= m <= min(n, 104) 1 <= queries[i] <= n queries[i] != root.val", Hard
2460,"You are given a 0-indexed array nums of size n consisting of non-negative integers.  You need to apply n - 1 operations to this array where, in the ith operation (0-indexed), you will apply the following on the ith element of nums:  If nums[i] == nums[i + 1], then multiply nums[i] by 2 and set nums[i + 1] to 0. Otherwise, you skip this operation. After performing all the operations, shift all the 0's to the end of the array.  For example, the array [1,0,2,0,0,1] after shifting all its 0's to the end, is [1,2,1,0,0,0]. Return the resulting array.  Note that the operations are applied sequentially, not all at once.     Example 1:  Input: nums = [1,2,2,1,1,0] Output: [1,4,2,0,0,0] Explanation: We do the following operations: - i = 0: nums[0] and nums[1] are not equal, so we skip this operation. - i = 1: nums[1] and nums[2] are equal, we multiply nums[1] by 2 and change nums[2] to 0. The array becomes [1,4,0,1,1,0]. - i = 2: nums[2] and nums[3] are not equal, so we skip this operation. - i = 3: nums[3] and nums[4] are equal, we multiply nums[3] by 2 and change nums[4] to 0. The array becomes [1,4,0,2,0,0]. - i = 4: nums[4] and nums[5] are equal, we multiply nums[4] by 2 and change nums[5] to 0. The array becomes [1,4,0,2,0,0]. After that, we shift the 0's to the end, which gives the array [1,4,2,0,0,0]. Example 2:  Input: nums = [0,1] Output: [1,0] Explanation: No operation can be applied, we just shift the 0 to the end.    Constraints:  2 <= nums.length <= 2000 0 <= nums[i] <= 1000", Easy
2461,"You are given an integer array nums and an integer k. Find the maximum subarray sum of all the subarrays of nums that meet the following conditions:  The length of the subarray is k, and All the elements of the subarray are distinct. Return the maximum subarray sum of all the subarrays that meet the conditions. If no subarray meets the conditions, return 0.  A subarray is a contiguous non-empty sequence of elements within an array.     Example 1:  Input: nums = [1,5,4,2,9,9,9], k = 3 Output: 15 Explanation: The subarrays of nums with length 3 are: - [1,5,4] which meets the requirements and has a sum of 10. - [5,4,2] which meets the requirements and has a sum of 11. - [4,2,9] which meets the requirements and has a sum of 15. - [2,9,9] which does not meet the requirements because the element 9 is repeated. - [9,9,9] which does not meet the requirements because the element 9 is repeated. We return 15 because it is the maximum subarray sum of all the subarrays that meet the conditions Example 2:  Input: nums = [4,4,4], k = 3 Output: 0 Explanation: The subarrays of nums with length 3 are: - [4,4,4] which does not meet the requirements because the element 4 is repeated. We return 0 because no subarrays meet the conditions.    Constraints:  1 <= k <= nums.length <= 105 1 <= nums[i] <= 105", Medium
2462,"You are given a 0-indexed integer array costs where costs[i] is the cost of hiring the ith worker.  You are also given two integers k and candidates. We want to hire exactly k workers according to the following rules:  You will run k sessions and hire exactly one worker in each session. In each hiring session, choose the worker with the lowest cost from either the first candidates workers or the last candidates workers. Break the tie by the smallest index. For example, if costs = [3,2,7,7,1,2] and candidates = 2, then in the first hiring session, we will choose the 4th worker because they have the lowest cost [3,2,7,7,1,2]. In the second hiring session, we will choose 1st worker because they have the same lowest cost as 4th worker but they have the smallest index [3,2,7,7,2]. Please note that the indexing may be changed in the process. If there are fewer than candidates workers remaining, choose the worker with the lowest cost among them. Break the tie by the smallest index. A worker can only be chosen once. Return the total cost to hire exactly k workers.     Example 1:  Input: costs = [17,12,10,2,7,2,11,20,8], k = 3, candidates = 4 Output: 11 Explanation: We hire 3 workers in total. The total cost is initially 0. - In the first hiring round we choose the worker from [17,12,10,2,7,2,11,20,8]. The lowest cost is 2, and we break the tie by the smallest index, which is 3. The total cost = 0 + 2 = 2. - In the second hiring round we choose the worker from [17,12,10,7,2,11,20,8]. The lowest cost is 2 (index 4). The total cost = 2 + 2 = 4. - In the third hiring round we choose the worker from [17,12,10,7,11,20,8]. The lowest cost is 7 (index 3). The total cost = 4 + 7 = 11. Notice that the worker with index 3 was common in the first and last four workers. The total hiring cost is 11. Example 2:  Input: costs = [1,2,4,1], k = 3, candidates = 3 Output: 4 Explanation: We hire 3 workers in total. The total cost is initially 0. - In the first hiring round we choose the worker from [1,2,4,1]. The lowest cost is 1, and we break the tie by the smallest index, which is 0. The total cost = 0 + 1 = 1. Notice that workers with index 1 and 2 are common in the first and last 3 workers. - In the second hiring round we choose the worker from [2,4,1]. The lowest cost is 1 (index 2). The total cost = 1 + 1 = 2. - In the third hiring round there are less than three candidates. We choose the worker from the remaining workers [2,4]. The lowest cost is 2 (index 0). The total cost = 2 + 2 = 4. The total hiring cost is 4.    Constraints:  1 <= costs.length <= 105 1 <= costs[i] <= 105 1 <= k, candidates <= costs.length", Medium
2463,"There are some robots and factories on the X-axis. You are given an integer array robot where robot[i] is the position of the ith robot. You are also given a 2D integer array factory where factory[j] = [positionj, limitj] indicates that positionj is the position of the jth factory and that the jth factory can repair at most limitj robots.  The positions of each robot are unique. The positions of each factory are also unique. Note that a robot can be in the same position as a factory initially.  All the robots are initially broken; they keep moving in one direction. The direction could be the negative or the positive direction of the X-axis. When a robot reaches a factory that did not reach its limit, the factory repairs the robot, and it stops moving.  At any moment, you can set the initial direction of moving for some robot. Your target is to minimize the total distance traveled by all the robots.  Return the minimum total distance traveled by all the robots. The test cases are generated such that all the robots can be repaired.  Note that  All robots move at the same speed. If two robots move in the same direction, they will never collide. If two robots move in opposite directions and they meet at some point, they do not collide. They cross each other. If a robot passes by a factory that reached its limits, it crosses it as if it does not exist. If the robot moved from a position x to a position y, the distance it moved is |y - x|.    Example 1:   Input: robot = [0,4,6], factory = [[2,2],[6,2]] Output: 4 Explanation: As shown in the figure: - The first robot at position 0 moves in the positive direction. It will be repaired at the first factory. - The second robot at position 4 moves in the negative direction. It will be repaired at the first factory. - The third robot at position 6 will be repaired at the second factory. It does not need to move. The limit of the first factory is 2, and it fixed 2 robots. The limit of the second factory is 2, and it fixed 1 robot. The total distance is |2 - 0| + |2 - 4| + |6 - 6| = 4. It can be shown that we cannot achieve a better total distance than 4. Example 2:   Input: robot = [1,-1], factory = [[-2,1],[2,1]] Output: 2 Explanation: As shown in the figure: - The first robot at position 1 moves in the positive direction. It will be repaired at the second factory. - The second robot at position -1 moves in the negative direction. It will be repaired at the first factory. The limit of the first factory is 1, and it fixed 1 robot. The limit of the second factory is 1, and it fixed 1 robot. The total distance is |2 - 1| + |(-2) - (-1)| = 2. It can be shown that we cannot achieve a better total distance than 2.    Constraints:  1 <= robot.length, factory.length <= 100 factory[j].length == 2 -109 <= robot[i], positionj <= 109 0 <= limitj <= robot.length The input will be generated such that it is always possible to repair every robot.", Hard
2465,"You are given a 0-indexed integer array nums of even length.  As long as nums is not empty, you must repetitively:  Find the minimum number in nums and remove it. Find the maximum number in nums and remove it. Calculate the average of the two removed numbers. The average of two numbers a and b is (a + b) / 2.  For example, the average of 2 and 3 is (2 + 3) / 2 = 2.5. Return the number of distinct averages calculated using the above process.  Note that when there is a tie for a minimum or maximum number, any can be removed.     Example 1:  Input: nums = [4,1,4,0,3,5] Output: 2 Explanation: 1. Remove 0 and 5, and the average is (0 + 5) / 2 = 2.5. Now, nums = [4,1,4,3]. 2. Remove 1 and 4. The average is (1 + 4) / 2 = 2.5, and nums = [4,3]. 3. Remove 3 and 4, and the average is (3 + 4) / 2 = 3.5. Since there are 2 distinct numbers among 2.5, 2.5, and 3.5, we return 2. Example 2:  Input: nums = [1,100] Output: 1 Explanation: There is only one average to be calculated after removing 1 and 100, so we return 1.    Constraints:  2 <= nums.length <= 100 nums.length is even. 0 <= nums[i] <= 100", Easy
2466,"Given the integers zero, one, low, and high, we can construct a string by starting with an empty string, and then at each step perform either of the following:  Append the character '0' zero times. Append the character '1' one times. This can be performed any number of times.  A good string is a string constructed by the above process having a length between low and high (inclusive).  Return the number of different good strings that can be constructed satisfying these properties. Since the answer can be large, return it modulo 109 + 7.     Example 1:  Input: low = 3, high = 3, zero = 1, one = 1 Output: 8 Explanation:  One possible valid good string is ""011"".  It can be constructed as follows: "" -> ""0"" -> ""01"" -> ""011"".  All binary strings from ""000"" to ""111"" are good strings in this example. Example 2:  Input: low = 2, high = 3, zero = 1, one = 2 Output: 5 Explanation: The good strings are ""00"", ""11"", ""000"", ""110"", and ""011"".    Constraints:  1 <= low <= high <= 105 1 <= zero, one <= low", Medium
2467,"There is an undirected tree with n nodes labeled from 0 to n - 1, rooted at node 0. You are given a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.  At every node i, there is a gate. You are also given an array of even integers amount, where amount[i] represents:  the price needed to open the gate at node i, if amount[i] is negative, or, the cash reward obtained on opening the gate at node i, otherwise. The game goes on as follows:  Initially, Alice is at node 0 and Bob is at node bob. At every second, Alice and Bob each move to an adjacent node. Alice moves towards some leaf node, while Bob moves towards node 0. For every node along their path, Alice and Bob either spend money to open the gate at that node, or accept the reward. Note that: If the gate is already open, no price will be required, nor will there be any cash reward. If Alice and Bob reach the node simultaneously, they share the price/reward for opening the gate there. In other words, if the price to open the gate is c, then both Alice and Bob pay c / 2 each. Similarly, if the reward at the gate is c, both of them receive c / 2 each. If Alice reaches a leaf node, she stops moving. Similarly, if Bob reaches node 0, he stops moving. Note that these events are independent of each other. Return the maximum net income Alice can have if she travels towards the optimal leaf node.     Example 1:   Input: edges = [[0,1],[1,2],[1,3],[3,4]], bob = 3, amount = [-2,4,2,-4,6] Output: 6 Explanation:  The above diagram represents the given tree. The game goes as follows: - Alice is initially on node 0, Bob on node 3. They open the gates of their respective nodes.   Alice's net income is now -2. - Both Alice and Bob move to node 1.    Since they reach here simultaneously, they open the gate together and share the reward.   Alice's net income becomes -2 + (4 / 2) = 0. - Alice moves on to node 3. Since Bob already opened its gate, Alice's income remains unchanged.   Bob moves on to node 0, and stops moving. - Alice moves on to node 4 and opens the gate there. Her net income becomes 0 + 6 = 6. Now, neither Alice nor Bob can make any further moves, and the game ends. It is not possible for Alice to get a higher net income. Example 2:   Input: edges = [[0,1]], bob = 1, amount = [-7280,2350] Output: -7280 Explanation:  Alice follows the path 0->1 whereas Bob follows the path 1->0. Thus, Alice opens the gate at node 0 only. Hence, her net income is -7280.     Constraints:  2 <= n <= 105 edges.length == n - 1 edges[i].length == 2 0 <= ai, bi < n ai != bi edges represents a valid tree. 1 <= bob < n amount.length == n amount[i] is an even integer in the range [-104, 104].", Medium
2468,"You are given a string, message, and a positive integer, limit.  You must split message into one or more parts based on limit. Each resulting part should have the suffix ""<a/b>"", where ""b"" is to be replaced with the total number of parts and ""a"" is to be replaced with the index of the part, starting from 1 and going up to b. Additionally, the length of each resulting part (including its suffix) should be equal to limit, except for the last part whose length can be at most limit.  The resulting parts should be formed such that when their suffixes are removed and they are all concatenated in order, they should be equal to message. Also, the result should contain as few parts as possible.  Return the parts message would be split into as an array of strings. If it is impossible to split message as required, return an empty array.     Example 1:  Input: message = ""this is really a very awesome message"", limit = 9 Output: [""thi<1/14>"",""s i<2/14>"",""s r<3/14>"",""eal<4/14>"",""ly <5/14>"",""a v<6/14>"",""ery<7/14>"","" aw<8/14>"",""eso<9/14>"",""me<10/14>"","" m<11/14>"",""es<12/14>"",""sa<13/14>"",""ge<14/14>""] Explanation: The first 9 parts take 3 characters each from the beginning of message. The next 5 parts take 2 characters each to finish splitting message.  In this example, each part, including the last, has length 9.  It can be shown it is not possible to split message into less than 14 parts. Example 2:  Input: message = ""short message"", limit = 15 Output: [""short mess<1/2>"",""age<2/2>""] Explanation: Under the given constraints, the string can be split into two parts:  - The first part comprises of the first 10 characters, and has a length 15. - The next part comprises of the last 3 characters, and has a length 8.    Constraints:  1 <= message.length <= 104 message consists only of lowercase English letters and ' '. 1 <= limit <= 104", Hard
2469,"You are given a non-negative floating point number rounded to two decimal places celsius, that denotes the temperature in Celsius.  You should convert Celsius into Kelvin and Fahrenheit and return it as an array ans = [kelvin, fahrenheit].  Return the array ans. Answers within 10-5 of the actual answer will be accepted.  Note that:  Kelvin = Celsius + 273.15 Fahrenheit = Celsius * 1.80 + 32.00    Example 1:  Input: celsius = 36.50 Output: [309.65000,97.70000] Explanation: Temperature at 36.50 Celsius converted in Kelvin is 309.65 and converted in Fahrenheit is 97.70. Example 2:  Input: celsius = 122.11 Output: [395.26000,251.79800] Explanation: Temperature at 122.11 Celsius converted in Kelvin is 395.26 and converted in Fahrenheit is 251.798.    Constraints:  0 <= celsius <= 1000", Easy
2470,"Given an integer array nums and an integer k, return the number of subarrays of nums where the least common multiple of the subarray's elements is k.  A subarray is a contiguous non-empty sequence of elements within an array.  The least common multiple of an array is the smallest positive integer that is divisible by all the array elements.     Example 1:  Input: nums = [3,6,2,7,1], k = 6 Output: 4 Explanation: The subarrays of nums where 6 is the least common multiple of all the subarray's elements are: - [3,6,2,7,1] - [3,6,2,7,1] - [3,6,2,7,1] - [3,6,2,7,1] Example 2:  Input: nums = [3], k = 2 Output: 0 Explanation: There are no subarrays of nums where 2 is the least common multiple of all the subarray's elements.    Constraints:  1 <= nums.length <= 1000 1 <= nums[i], k <= 1000", Medium
2471,"You are given the root of a binary tree with unique values.  In one operation, you can choose any two nodes at the same level and swap their values.  Return the minimum number of operations needed to make the values at each level sorted in a strictly increasing order.  The level of a node is the number of edges along the path between it and the root node.     Example 1:   Input: root = [1,4,3,7,6,8,5,null,null,null,null,9,null,10] Output: 3 Explanation: - Swap 4 and 3. The 2nd level becomes [3,4]. - Swap 7 and 5. The 3rd level becomes [5,6,8,7]. - Swap 8 and 7. The 3rd level becomes [5,6,7,8]. We used 3 operations so return 3. It can be proven that 3 is the minimum number of operations needed. Example 2:   Input: root = [1,3,2,7,6,5,4] Output: 3 Explanation: - Swap 3 and 2. The 2nd level becomes [2,3]. - Swap 7 and 4. The 3rd level becomes [4,6,5,7]. - Swap 6 and 5. The 3rd level becomes [4,5,6,7]. We used 3 operations so return 3. It can be proven that 3 is the minimum number of operations needed. Example 3:   Input: root = [1,2,3,4,5,6] Output: 0 Explanation: Each level is already sorted in increasing order so return 0.    Constraints:  The number of nodes in the tree is in the range [1, 105]. 1 <= Node.val <= 105 All the values of the tree are unique.", Medium
2472,"You are given a string s and a positive integer k.  Select a set of non-overlapping substrings from the string s that satisfy the following conditions:  The length of each substring is at least k. Each substring is a palindrome. Return the maximum number of substrings in an optimal selection.  A substring is a contiguous sequence of characters within a string.     Example 1:  Input: s = ""abaccdbbd"", k = 3 Output: 2 Explanation: We can select the substrings underlined in s = ""abaccdbbd"". Both ""aba"" and ""dbbd"" are palindromes and have a length of at least k = 3. It can be shown that we cannot find a selection with more than two valid substrings. Example 2:  Input: s = ""adbcda"", k = 2 Output: 0 Explanation: There is no palindrome substring of length at least 2 in the string.    Constraints:  1 <= k <= s.length <= 2000 s consists of lowercase English letters.", Hard
2475,"You are given a 0-indexed array of positive integers nums. Find the number of triplets (i, j, k) that meet the following conditions:  0 <= i < j < k < nums.length nums[i], nums[j], and nums[k] are pairwise distinct. In other words, nums[i] != nums[j], nums[i] != nums[k], and nums[j] != nums[k]. Return the number of triplets that meet the conditions.     Example 1:  Input: nums = [4,4,2,4,3] Output: 3 Explanation: The following triplets meet the conditions: - (0, 2, 4) because 4 != 2 != 3 - (1, 2, 4) because 4 != 2 != 3 - (2, 3, 4) because 2 != 4 != 3 Since there are 3 triplets, we return 3. Note that (2, 0, 4) is not a valid triplet because 2 > 0. Example 2:  Input: nums = [1,1,1,1,1] Output: 0 Explanation: No triplets meet the conditions so we return 0.    Constraints:  3 <= nums.length <= 100 1 <= nums[i] <= 1000", Easy
2476,"You are given the root of a binary search tree and an array queries of size n consisting of positive integers.  Find a 2D array answer of size n where answer[i] = [mini, maxi]:  mini is the largest value in the tree that is smaller than or equal to queries[i]. If a such value does not exist, add -1 instead. maxi is the smallest value in the tree that is greater than or equal to queries[i]. If a such value does not exist, add -1 instead. Return the array answer.     Example 1:   Input: root = [6,2,13,1,4,9,15,null,null,null,null,null,null,14], queries = [2,5,16] Output: [[2,2],[4,6],[15,-1]] Explanation: We answer the queries in the following way: - The largest number that is smaller or equal than 2 in the tree is 2, and the smallest number that is greater or equal than 2 is still 2. So the answer for the first query is [2,2]. - The largest number that is smaller or equal than 5 in the tree is 4, and the smallest number that is greater or equal than 5 is 6. So the answer for the second query is [4,6]. - The largest number that is smaller or equal than 16 in the tree is 15, and the smallest number that is greater or equal than 16 does not exist. So the answer for the third query is [15,-1]. Example 2:   Input: root = [4,null,9], queries = [3] Output: [[-1,4]] Explanation: The largest number that is smaller or equal to 3 in the tree does not exist, and the smallest number that is greater or equal to 3 is 4. So the answer for the query is [-1,4].    Constraints:  The number of nodes in the tree is in the range [2, 105]. 1 <= Node.val <= 106 n == queries.length 1 <= n <= 105 1 <= queries[i] <= 106", Medium
2477,"There is a tree (i.e., a connected, undirected graph with no cycles) structure country network consisting of n cities numbered from 0 to n - 1 and exactly n - 1 roads. The capital city is city 0. You are given a 2D integer array roads where roads[i] = [ai, bi] denotes that there exists a bidirectional road connecting cities ai and bi.  There is a meeting for the representatives of each city. The meeting is in the capital city.  There is a car in each city. You are given an integer seats that indicates the number of seats in each car.  A representative can use the car in their city to travel or change the car and ride with another representative. The cost of traveling between two cities is one liter of fuel.  Return the minimum number of liters of fuel to reach the capital city.     Example 1:   Input: roads = [[0,1],[0,2],[0,3]], seats = 5 Output: 3 Explanation:  - Representative1 goes directly to the capital with 1 liter of fuel. - Representative2 goes directly to the capital with 1 liter of fuel. - Representative3 goes directly to the capital with 1 liter of fuel. It costs 3 liters of fuel at minimum.  It can be proven that 3 is the minimum number of liters of fuel needed. Example 2:   Input: roads = [[3,1],[3,2],[1,0],[0,4],[0,5],[4,6]], seats = 2 Output: 7 Explanation:  - Representative2 goes directly to city 3 with 1 liter of fuel. - Representative2 and representative3 go together to city 1 with 1 liter of fuel. - Representative2 and representative3 go together to the capital with 1 liter of fuel. - Representative1 goes directly to the capital with 1 liter of fuel. - Representative5 goes directly to the capital with 1 liter of fuel. - Representative6 goes directly to city 4 with 1 liter of fuel. - Representative4 and representative6 go together to the capital with 1 liter of fuel. It costs 7 liters of fuel at minimum.  It can be proven that 7 is the minimum number of liters of fuel needed. Example 3:   Input: roads = [], seats = 1 Output: 0 Explanation: No representatives need to travel to the capital city.    Constraints:  1 <= n <= 105 roads.length == n - 1 roads[i].length == 2 0 <= ai, bi < n ai != bi roads represents a valid tree. 1 <= seats <= 105", Medium
2478,"You are given a string s that consists of the digits '1' to '9' and two integers k and minLength.  A partition of s is called beautiful if:  s is partitioned into k non-intersecting substrings. Each substring has a length of at least minLength. Each substring starts with a prime digit and ends with a non-prime digit. Prime digits are '2', '3', '5', and '7', and the rest of the digits are non-prime. Return the number of beautiful partitions of s. Since the answer may be very large, return it modulo 109 + 7.  A substring is a contiguous sequence of characters within a string.     Example 1:  Input: s = ""23542185131"", k = 3, minLength = 2 Output: 3 Explanation: There exists three ways to create a beautiful partition: ""2354 | 218 | 5131"" ""2354 | 21851 | 31"" ""2354218 | 51 | 31"" Example 2:  Input: s = ""23542185131"", k = 3, minLength = 3 Output: 1 Explanation: There exists one way to create a beautiful partition: ""2354 | 218 | 5131"". Example 3:  Input: s = ""3312958"", k = 3, minLength = 1 Output: 1 Explanation: There exists one way to create a beautiful partition: ""331 | 29 | 58"".    Constraints:  1 <= k, minLength <= s.length <= 1000 s consists of the digits '1' to '9'.", Hard
2481,"A valid cut in a circle can be:  A cut that is represented by a straight line that touches two points on the edge of the circle and passes through its center, or A cut that is represented by a straight line that touches one point on the edge of the circle and its center. Some valid and invalid cuts are shown in the figures below.   Given the integer n, return the minimum number of cuts needed to divide a circle into n equal slices.     Example 1:   Input: n = 4 Output: 2 Explanation:  The above figure shows how cutting the circle twice through the middle divides it into 4 equal slices. Example 2:   Input: n = 3 Output: 3 Explanation: At least 3 cuts are needed to divide the circle into 3 equal slices.  It can be shown that less than 3 cuts cannot result in 3 slices of equal size and shape. Also note that the first cut will not divide the circle into distinct parts.    Constraints:  1 <= n <= 100", Easy
2482,"You are given a 0-indexed m x n binary matrix grid.  A 0-indexed m x n difference matrix diff is created with the following procedure:  Let the number of ones in the ith row be onesRowi. Let the number of ones in the jth column be onesColj. Let the number of zeros in the ith row be zerosRowi. Let the number of zeros in the jth column be zerosColj. diff[i][j] = onesRowi + onesColj - zerosRowi - zerosColj Return the difference matrix diff.     Example 1:   Input: grid = [[0,1,1],[1,0,1],[0,0,1]] Output: [[0,0,4],[0,0,4],[-2,-2,2]] Explanation: - diff[0][0] = onesRow0 + onesCol0 - zerosRow0 - zerosCol0 = 2 + 1 - 1 - 2 = 0  - diff[0][1] = onesRow0 + onesCol1 - zerosRow0 - zerosCol1 = 2 + 1 - 1 - 2 = 0  - diff[0][2] = onesRow0 + onesCol2 - zerosRow0 - zerosCol2 = 2 + 3 - 1 - 0 = 4  - diff[1][0] = onesRow1 + onesCol0 - zerosRow1 - zerosCol0 = 2 + 1 - 1 - 2 = 0  - diff[1][1] = onesRow1 + onesCol1 - zerosRow1 - zerosCol1 = 2 + 1 - 1 - 2 = 0  - diff[1][2] = onesRow1 + onesCol2 - zerosRow1 - zerosCol2 = 2 + 3 - 1 - 0 = 4  - diff[2][0] = onesRow2 + onesCol0 - zerosRow2 - zerosCol0 = 1 + 1 - 2 - 2 = -2 - diff[2][1] = onesRow2 + onesCol1 - zerosRow2 - zerosCol1 = 1 + 1 - 2 - 2 = -2 - diff[2][2] = onesRow2 + onesCol2 - zerosRow2 - zerosCol2 = 1 + 3 - 2 - 0 = 2 Example 2:   Input: grid = [[1,1,1],[1,1,1]] Output: [[5,5,5],[5,5,5]] Explanation: - diff[0][0] = onesRow0 + onesCol0 - zerosRow0 - zerosCol0 = 3 + 2 - 0 - 0 = 5 - diff[0][1] = onesRow0 + onesCol1 - zerosRow0 - zerosCol1 = 3 + 2 - 0 - 0 = 5 - diff[0][2] = onesRow0 + onesCol2 - zerosRow0 - zerosCol2 = 3 + 2 - 0 - 0 = 5 - diff[1][0] = onesRow1 + onesCol0 - zerosRow1 - zerosCol0 = 3 + 2 - 0 - 0 = 5 - diff[1][1] = onesRow1 + onesCol1 - zerosRow1 - zerosCol1 = 3 + 2 - 0 - 0 = 5 - diff[1][2] = onesRow1 + onesCol2 - zerosRow1 - zerosCol2 = 3 + 2 - 0 - 0 = 5    Constraints:  m == grid.length n == grid[i].length 1 <= m, n <= 105 1 <= m * n <= 105 grid[i][j] is either 0 or 1.", Medium
2483,"You are given the customer visit log of a shop represented by a 0-indexed string customers consisting only of characters 'N' and 'Y':  if the ith character is 'Y', it means that customers come at the ith hour whereas 'N' indicates that no customers come at the ith hour. If the shop closes at the jth hour (0 <= j <= n), the penalty is calculated as follows:  For every hour when the shop is open and no customers come, the penalty increases by 1. For every hour when the shop is closed and customers come, the penalty increases by 1. Return the earliest hour at which the shop must be closed to incur a minimum penalty.  Note that if a shop closes at the jth hour, it means the shop is closed at the hour j.     Example 1:  Input: customers = ""YYNY"" Output: 2 Explanation:  - Closing the shop at the 0th hour incurs in 1+1+0+1 = 3 penalty. - Closing the shop at the 1st hour incurs in 0+1+0+1 = 2 penalty. - Closing the shop at the 2nd hour incurs in 0+0+0+1 = 1 penalty. - Closing the shop at the 3rd hour incurs in 0+0+1+1 = 2 penalty. - Closing the shop at the 4th hour incurs in 0+0+1+0 = 1 penalty. Closing the shop at 2nd or 4th hour gives a minimum penalty. Since 2 is earlier, the optimal closing time is 2. Example 2:  Input: customers = ""NNNNN"" Output: 0 Explanation: It is best to close the shop at the 0th hour as no customers arrive. Example 3:  Input: customers = ""YYYY"" Output: 4 Explanation: It is best to close the shop at the 4th hour as customers arrive at each hour.    Constraints:  1 <= customers.length <= 105 customers consists only of characters 'Y' and 'N'.", Medium
2484,"Given a string of digits s, return the number of palindromic subsequences of s having length 5. Since the answer may be very large, return it modulo 109 + 7.  Note:  A string is palindromic if it reads the same forward and backward. A subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.    Example 1:  Input: s = ""103301"" Output: 2 Explanation:  There are 6 possible subsequences of length 5: ""10330"",""10331"",""10301"",""10301"",""13301"",""03301"".  Two of them (both equal to ""10301"") are palindromic. Example 2:  Input: s = ""0000000"" Output: 21 Explanation: All 21 subsequences are ""00000"", which is palindromic. Example 3:  Input: s = ""9999900000"" Output: 2 Explanation: The only two palindromic subsequences are ""99999"" and ""00000"".    Constraints:  1 <= s.length <= 104 s consists of digits.", Hard
2485,"Given a positive integer n, find the pivot integer x such that:  The sum of all elements between 1 and x inclusively equals the sum of all elements between x and n inclusively. Return the pivot integer x. If no such integer exists, return -1. It is guaranteed that there will be at most one pivot index for the given input.     Example 1:  Input: n = 8 Output: 6 Explanation: 6 is the pivot integer since: 1 + 2 + 3 + 4 + 5 + 6 = 6 + 7 + 8 = 21. Example 2:  Input: n = 1 Output: 1 Explanation: 1 is the pivot integer since: 1 = 1. Example 3:  Input: n = 4 Output: -1 Explanation: It can be proved that no such integer exist.    Constraints:  1 <= n <= 1000", Easy
2486,"You are given two strings s and t consisting of only lowercase English letters.  Return the minimum number of characters that need to be appended to the end of s so that t becomes a subsequence of s.  A subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.     Example 1:  Input: s = ""coaching"", t = ""coding"" Output: 4 Explanation: Append the characters ""ding"" to the end of s so that s = ""coachingding"". Now, t is a subsequence of s (""coachingding""). It can be shown that appending any 3 characters to the end of s will never make t a subsequence. Example 2:  Input: s = ""abcde"", t = ""a"" Output: 0 Explanation: t is already a subsequence of s (""abcde""). Example 3:  Input: s = ""z"", t = ""abcde"" Output: 5 Explanation: Append the characters ""abcde"" to the end of s so that s = ""zabcde"". Now, t is a subsequence of s (""zabcde""). It can be shown that appending any 4 characters to the end of s will never make t a subsequence.    Constraints:  1 <= s.length, t.length <= 105 s and t consist only of lowercase English letters.", Medium
2487,"You are given the head of a linked list.  Remove every node which has a node with a strictly greater value anywhere to the right side of it.  Return the head of the modified linked list.     Example 1:   Input: head = [5,2,13,3,8] Output: [13,8] Explanation: The nodes that should be removed are 5, 2 and 3. - Node 13 is to the right of node 5. - Node 13 is to the right of node 2. - Node 8 is to the right of node 3. Example 2:  Input: head = [1,1,1,1] Output: [1,1,1,1] Explanation: Every node has value 1, so no nodes are removed.    Constraints:  The number of the nodes in the given list is in the range [1, 105]. 1 <= Node.val <= 105", Medium
2488,"You are given an array nums of size n consisting of distinct integers from 1 to n and a positive integer k.  Return the number of non-empty subarrays in nums that have a median equal to k.  Note:  The median of an array is the middle element after sorting the array in ascending order. If the array is of even length, the median is the left middle element. For example, the median of [2,3,1,4] is 2, and the median of [8,4,3,5,1] is 4. A subarray is a contiguous part of an array.    Example 1:  Input: nums = [3,2,1,4,5], k = 4 Output: 3 Explanation: The subarrays that have a median equal to 4 are: [4], [4,5] and [1,4,5]. Example 2:  Input: nums = [2,3,1], k = 3 Output: 1 Explanation: [3] is the only subarray that has a median equal to 3.    Constraints:  n == nums.length 1 <= n <= 105 1 <= nums[i], k <= n The integers in nums are distinct.", Hard
2490,"A sentence is a list of words that are separated by a single space with no leading or trailing spaces.  For example, ""Hello World"", ""HELLO"", ""hello world hello world"" are all sentences. Words consist of only uppercase and lowercase English letters. Uppercase and lowercase English letters are considered different.  A sentence is circular if:  The last character of a word is equal to the first character of the next word. The last character of the last word is equal to the first character of the first word. For example, ""leetcode exercises sound delightful"", ""eetcode"", ""leetcode eats soul"" are all circular sentences. However, ""Leetcode is cool"", ""happy Leetcode"", ""Leetcode"" and ""I like Leetcode"" are not circular sentences.  Given a string sentence, return true if it is circular. Otherwise, return false.     Example 1:  Input: sentence = ""leetcode exercises sound delightful"" Output: true Explanation: The words in sentence are [""leetcode"", ""exercises"", ""sound"", ""delightful""]. - leetcode's last character is equal to exercises's first character. - exercises's last character is equal to sound's first character. - sound's last character is equal to delightful's first character. - delightful's last character is equal to leetcode's first character. The sentence is circular. Example 2:  Input: sentence = ""eetcode"" Output: true Explanation: The words in sentence are [""eetcode""]. - eetcode's last character is equal to eetcode's first character. The sentence is circular. Example 3:  Input: sentence = ""Leetcode is cool"" Output: false Explanation: The words in sentence are [""Leetcode"", ""is"", ""cool""]. - Leetcode's last character is not equal to is's first character. The sentence is not circular.    Constraints:  1 <= sentence.length <= 500 sentence consist of only lowercase and uppercase English letters and spaces. The words in sentence are separated by a single space. There are no leading or trailing spaces.", Easy
2491,"You are given a positive integer array skill of even length n where skill[i] denotes the skill of the ith player. Divide the players into n / 2 teams of size 2 such that the total skill of each team is equal.  The chemistry of a team is equal to the product of the skills of the players on that team.  Return the sum of the chemistry of all the teams, or return -1 if there is no way to divide the players into teams such that the total skill of each team is equal.     Example 1:  Input: skill = [3,2,5,1,3,4] Output: 22 Explanation:  Divide the players into the following teams: (1, 5), (2, 4), (3, 3), where each team has a total skill of 6. The sum of the chemistry of all the teams is: 1 * 5 + 2 * 4 + 3 * 3 = 5 + 8 + 9 = 22. Example 2:  Input: skill = [3,4] Output: 12 Explanation:  The two players form a team with a total skill of 7. The chemistry of the team is 3 * 4 = 12. Example 3:  Input: skill = [1,1,2,3] Output: -1 Explanation:  There is no way to divide the players into teams such that the total skill of each team is equal.    Constraints:  2 <= skill.length <= 105 skill.length is even. 1 <= skill[i] <= 1000", Medium
2492,"You are given a positive integer n representing n cities numbered from 1 to n. You are also given a 2D array roads where roads[i] = [ai, bi, distancei] indicates that there is a bidirectional road between cities ai and bi with a distance equal to distancei. The cities graph is not necessarily connected.  The score of a path between two cities is defined as the minimum distance of a road in this path.  Return the minimum possible score of a path between cities 1 and n.  Note:  A path is a sequence of roads between two cities. It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path. The test cases are generated such that there is at least one path between 1 and n.    Example 1:   Input: n = 4, roads = [[1,2,9],[2,3,6],[2,4,5],[1,4,7]] Output: 5 Explanation: The path from city 1 to 4 with the minimum score is: 1 -> 2 -> 4. The score of this path is min(9,5) = 5. It can be shown that no other path has less score. Example 2:   Input: n = 4, roads = [[1,2,2],[1,3,4],[3,4,7]] Output: 2 Explanation: The path from city 1 to 4 with the minimum score is: 1 -> 2 -> 1 -> 3 -> 4. The score of this path is min(2,2,4,7) = 2.    Constraints:  2 <= n <= 105 1 <= roads.length <= 105 roads[i].length == 3 1 <= ai, bi <= n ai != bi 1 <= distancei <= 104 There are no repeated edges. There is at least one path between 1 and n.", Medium
2493,"You are given a positive integer n representing the number of nodes in an undirected graph. The nodes are labeled from 1 to n.  You are also given a 2D integer array edges, where edges[i] = [ai, bi] indicates that there is a bidirectional edge between nodes ai and bi. Notice that the given graph may be disconnected.  Divide the nodes of the graph into m groups (1-indexed) such that:  Each node in the graph belongs to exactly one group. For every pair of nodes in the graph that are connected by an edge [ai, bi], if ai belongs to the group with index x, and bi belongs to the group with index y, then |y - x| = 1. Return the maximum number of groups (i.e., maximum m) into which you can divide the nodes. Return -1 if it is impossible to group the nodes with the given conditions.     Example 1:   Input: n = 6, edges = [[1,2],[1,4],[1,5],[2,6],[2,3],[4,6]] Output: 4 Explanation: As shown in the image we: - Add node 5 to the first group. - Add node 1 to the second group. - Add nodes 2 and 4 to the third group. - Add nodes 3 and 6 to the fourth group. We can see that every edge is satisfied. It can be shown that that if we create a fifth group and move any node from the third or fourth group to it, at least on of the edges will not be satisfied. Example 2:  Input: n = 3, edges = [[1,2],[2,3],[3,1]] Output: -1 Explanation: If we add node 1 to the first group, node 2 to the second group, and node 3 to the third group to satisfy the first two edges, we can see that the third edge will not be satisfied. It can be shown that no grouping is possible.    Constraints:  1 <= n <= 500 1 <= edges.length <= 104 edges[i].length == 2 1 <= ai, bi <= n ai != bi There is at most one edge between any pair of vertices.", Hard
2496,"The value of an alphanumeric string can be defined as:  The numeric representation of the string in base 10, if it comprises of digits only. The length of the string, otherwise. Given an array strs of alphanumeric strings, return the maximum value of any string in strs.     Example 1:  Input: strs = [""alic3"",""bob"",""3"",""4"",""00000""] Output: 5 Explanation:  - ""alic3"" consists of both letters and digits, so its value is its length, i.e. 5. - ""bob"" consists only of letters, so its value is also its length, i.e. 3. - ""3"" consists only of digits, so its value is its numeric equivalent, i.e. 3. - ""4"" also consists only of digits, so its value is 4. - ""00000"" consists only of digits, so its value is 0. Hence, the maximum value is 5, of ""alic3"". Example 2:  Input: strs = [""1"",""01"",""001"",""0001""] Output: 1 Explanation:  Each string in the array has value 1. Hence, we return 1.    Constraints:  1 <= strs.length <= 100 1 <= strs[i].length <= 9 strs[i] consists of only lowercase English letters and digits.", Easy
2497,"There is an undirected graph consisting of n nodes numbered from 0 to n - 1. You are given a 0-indexed integer array vals of length n where vals[i] denotes the value of the ith node.  You are also given a 2D integer array edges where edges[i] = [ai, bi] denotes that there exists an undirected edge connecting nodes ai and bi.  A star graph is a subgraph of the given graph having a center node containing 0 or more neighbors. In other words, it is a subset of edges of the given graph such that there exists a common node for all edges.  The image below shows star graphs with 3 and 4 neighbors respectively, centered at the blue node.   The star sum is the sum of the values of all the nodes present in the star graph.  Given an integer k, return the maximum star sum of a star graph containing at most k edges.     Example 1:   Input: vals = [1,2,3,4,10,-10,-20], edges = [[0,1],[1,2],[1,3],[3,4],[3,5],[3,6]], k = 2 Output: 16 Explanation: The above diagram represents the input graph. The star graph with the maximum star sum is denoted by blue. It is centered at 3 and includes its neighbors 1 and 4. It can be shown it is not possible to get a star graph with a sum greater than 16. Example 2:  Input: vals = [-5], edges = [], k = 0 Output: -5 Explanation: There is only one possible star graph, which is node 0 itself. Hence, we return -5.    Constraints:  n == vals.length 1 <= n <= 105 -104 <= vals[i] <= 104 0 <= edges.length <= min(n * (n - 1) / 2, 105) edges[i].length == 2 0 <= ai, bi <= n - 1 ai != bi 0 <= k <= n - 1", Medium
2498,"You are given a 0-indexed integer array stones sorted in strictly increasing order representing the positions of stones in a river.  A frog, initially on the first stone, wants to travel to the last stone and then return to the first stone. However, it can jump to any stone at most once.  The length of a jump is the absolute difference between the position of the stone the frog is currently on and the position of the stone to which the frog jumps.  More formally, if the frog is at stones[i] and is jumping to stones[j], the length of the jump is |stones[i] - stones[j]|. The cost of a path is the maximum length of a jump among all jumps in the path.  Return the minimum cost of a path for the frog.     Example 1:   Input: stones = [0,2,5,6,7] Output: 5 Explanation: The above figure represents one of the optimal paths the frog can take. The cost of this path is 5, which is the maximum length of a jump. Since it is not possible to achieve a cost of less than 5, we return it. Example 2:   Input: stones = [0,3,9] Output: 9 Explanation:  The frog can jump directly to the last stone and come back to the first stone.  In this case, the length of each jump will be 9. The cost for the path will be max(9, 9) = 9. It can be shown that this is the minimum achievable cost.    Constraints:  2 <= stones.length <= 105 0 <= stones[i] <= 109 stones[0] == 0 stones is sorted in a strictly increasing order.", Medium
2499,"You are given two 0-indexed integer arrays nums1 and nums2, of equal length n.  In one operation, you can swap the values of any two indices of nums1. The cost of this operation is the sum of the indices.  Find the minimum total cost of performing the given operation any number of times such that nums1[i] != nums2[i] for all 0 <= i <= n - 1 after performing all the operations.  Return the minimum total cost such that nums1 and nums2 satisfy the above condition. In case it is not possible, return -1.     Example 1:  Input: nums1 = [1,2,3,4,5], nums2 = [1,2,3,4,5] Output: 10 Explanation:  One of the ways we can perform the operations is: - Swap values at indices 0 and 3, incurring cost = 0 + 3 = 3. Now, nums1 = [4,2,3,1,5] - Swap values at indices 1 and 2, incurring cost = 1 + 2 = 3. Now, nums1 = [4,3,2,1,5]. - Swap values at indices 0 and 4, incurring cost = 0 + 4 = 4. Now, nums1 =[5,3,2,1,4]. We can see that for each index i, nums1[i] != nums2[i]. The cost required here is 10. Note that there are other ways to swap values, but it can be proven that it is not possible to obtain a cost less than 10. Example 2:  Input: nums1 = [2,2,2,1,3], nums2 = [1,2,2,3,3] Output: 10 Explanation:  One of the ways we can perform the operations is: - Swap values at indices 2 and 3, incurring cost = 2 + 3 = 5. Now, nums1 = [2,2,1,2,3]. - Swap values at indices 1 and 4, incurring cost = 1 + 4 = 5. Now, nums1 = [2,3,1,2,2]. The total cost needed here is 10, which is the minimum possible. Example 3:  Input: nums1 = [1,2,2], nums2 = [1,2,2] Output: -1 Explanation:  It can be shown that it is not possible to satisfy the given conditions irrespective of the number of operations we perform. Hence, we return -1.    Constraints:  n == nums1.length == nums2.length 1 <= n <= 105 1 <= nums1[i], nums2[i] <= n", Hard
2500,"You are given an m x n matrix grid consisting of positive integers.  Perform the following operation until grid becomes empty:  Delete the element with the greatest value from each row. If multiple such elements exist, delete any of them. Add the maximum of deleted elements to the answer. Note that the number of columns decreases by one after each operation.  Return the answer after performing the operations described above.     Example 1:   Input: grid = [[1,2,4],[3,3,1]] Output: 8 Explanation: The diagram above shows the removed values in each step. - In the first operation, we remove 4 from the first row and 3 from the second row (notice that, there are two cells with value 3 and we can remove any of them). We add 4 to the answer. - In the second operation, we remove 2 from the first row and 3 from the second row. We add 3 to the answer. - In the third operation, we remove 1 from the first row and 1 from the second row. We add 1 to the answer. The final answer = 4 + 3 + 1 = 8. Example 2:   Input: grid = [[10]] Output: 10 Explanation: The diagram above shows the removed values in each step. - In the first operation, we remove 10 from the first row. We add 10 to the answer. The final answer = 10.    Constraints:  m == grid.length n == grid[i].length 1 <= m, n <= 50 1 <= grid[i][j] <= 100", Easy
2501,"You are given an integer array nums. A subsequence of nums is called a square streak if:  The length of the subsequence is at least 2, and after sorting the subsequence, each element (except the first element) is the square of the previous number. Return the length of the longest square streak in nums, or return -1 if there is no square streak.  A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.     Example 1:  Input: nums = [4,3,6,16,8,2] Output: 3 Explanation: Choose the subsequence [4,16,2]. After sorting it, it becomes [2,4,16]. - 4 = 2 * 2. - 16 = 4 * 4. Therefore, [4,16,2] is a square streak. It can be shown that every subsequence of length 4 is not a square streak. Example 2:  Input: nums = [2,3,5,6,7] Output: -1 Explanation: There is no square streak in nums so return -1.    Constraints:  2 <= nums.length <= 105 2 <= nums[i] <= 105", Medium
2502,"You are given an integer n representing the size of a 0-indexed memory array. All memory units are initially free.  You have a memory allocator with the following functionalities:  Allocate a block of size consecutive free memory units and assign it the id mID. Free all memory units with the given id mID. Note that:  Multiple blocks can be allocated to the same mID. You should free all the memory units with mID, even if they were allocated in different blocks. Implement the Allocator class:  Allocator(int n) Initializes an Allocator object with a memory array of size n. int allocate(int size, int mID) Find the leftmost block of size consecutive free memory units and allocate it with the id mID. Return the block's first index. If such a block does not exist, return -1. int free(int mID) Free all memory units with the id mID. Return the number of memory units you have freed.    Example 1:  Input [""Allocator"", ""allocate"", ""allocate"", ""allocate"", '""Free"", ""allocate"", ""allocate"", ""allocate"", '""Free"", ""allocate"", '""Free""] [[10], [1, 1], [1, 2], [1, 3], [2], [3, 4], [1, 1], [1, 1], [1], [10, 2], [7]] Output [null, 0, 1, 2, 1, 3, 1, 6, 3, -1, 0]  Explanation Allocator loc = new Allocator(10); // Initialize a memory array of size 10. All memory units are initially free. loc.allocate(1, 1); // The leftmost block's first index is 0. The memory array becomes [1,_,_,_,_,_,_,_,_,_]. We return 0. loc.allocate(1, 2); // The leftmost block's first index is 1. The memory array becomes [1,2,_,_,_,_,_,_,_,_]. We return 1. loc.allocate(1, 3); // The leftmost block's first index is 2. The memory array becomes [1,2,3,_,_,_,_,_,_,_]. We return 2. loc.free(2); // Free all memory units with mID 2. The memory array becomes [1,_, 3,_,_,_,_,_,_,_]. We return 1 since there is only 1 unit with mID 2. loc.allocate(3, 4); // The leftmost block's first index is 3. The memory array becomes [1,_,3,4,4,4,_,_,_,_]. We return 3. loc.allocate(1, 1); // The leftmost block's first index is 1. The memory array becomes [1,1,3,4,4,4,_,_,_,_]. We return 1. loc.allocate(1, 1); // The leftmost block's first index is 6. The memory array becomes [1,1,3,4,4,4,1,_,_,_]. We return 6. loc.free(1); // Free all memory units with mID 1. The memory array becomes [_,_,3,4,4,4,_,_,_,_]. We return 3 since there are 3 units with mID 1. loc.allocate(10, 2); // We can not find any free block with 10 consecutive free memory units, so we return -1. loc.free(7); // Free all memory units with mID 7. The memory array remains the same since there is no memory unit with mID 7. We return 0.    Constraints:  1 <= n, size, mID <= 1000 At most 1000 calls will be made to allocate and free.", Medium
2503,"You are given an m x n integer matrix grid and an array queries of size k.  Find an array answer of size k such that for each integer queries[i] you start in the top left cell of the matrix and repeat the following process:  If queries[i] is strictly greater than the value of the current cell that you are in, then you get one point if it is your first time visiting this cell, and you can move to any adjacent cell in all 4 directions: up, down, left, and right. Otherwise, you do not get any points, and you end this process. After the process, answer[i] is the maximum number of points you can get. Note that for each query you are allowed to visit the same cell multiple times.  Return the resulting array answer.     Example 1:   Input: grid = [[1,2,3],[2,5,7],[3,5,1]], queries = [5,6,2] Output: [5,8,1] Explanation: The diagrams above show which cells we visit to get points for each query. Example 2:   Input: grid = [[5,2,1],[1,1,2]], queries = [3] Output: [0] Explanation: We can not get any points because the value of the top left cell is already greater than or equal to 3.    Constraints:  m == grid.length n == grid[i].length 2 <= m, n <= 1000 4 <= m * n <= 105 k == queries.length 1 <= k <= 104 1 <= grid[i][j], queries[i] <= 106", Hard
2506,"You are given a 0-indexed string array words.  Two strings are similar if they consist of the same characters.  For example, ""abca"" and ""cba"" are similar since both consist of characters 'a', 'b', and 'c'. However, ""abacba"" and ""bcfd"" are not similar since they do not consist of the same characters. Return the number of pairs (i, j) such that 0 <= i < j <= word.length - 1 and the two strings words[i] and words[j] are similar.     Example 1:  Input: words = [""aba"",""aabb"",""abcd"",""bac"",""aabc""] Output: 2 Explanation: There are 2 pairs that satisfy the conditions: - i = 0 and j = 1 : both words[0] and words[1] only consist of characters 'a' and 'b'.  - i = 3 and j = 4 : both words[3] and words[4] only consist of characters 'a', 'b', and 'c'.  Example 2:  Input: words = [""aabb"",""ab"",""ba""] Output: 3 Explanation: There are 3 pairs that satisfy the conditions: - i = 0 and j = 1 : both words[0] and words[1] only consist of characters 'a' and 'b'.  - i = 0 and j = 2 : both words[0] and words[2] only consist of characters 'a' and 'b'. - i = 1 and j = 2 : both words[1] and words[2] only consist of characters 'a' and 'b'. Example 3:  Input: words = [""nba"",""cba"",""dba""] Output: 0 Explanation: Since there does not exist any pair that satisfies the conditions, we return 0.    Constraints:  1 <= words.length <= 100 1 <= words[i].length <= 100 words[i] consist of only lowercase English letters.", Easy
2507,"You are given a positive integer n.  Continuously replace n with the sum of its prime factors.  Note that if a prime factor divides n multiple times, it should be included in the sum as many times as it divides n. Return the smallest value n will take on.     Example 1:  Input: n = 15 Output: 5 Explanation: Initially, n = 15. 15 = 3 * 5, so replace n with 3 + 5 = 8. 8 = 2 * 2 * 2, so replace n with 2 + 2 + 2 = 6. 6 = 2 * 3, so replace n with 2 + 3 = 5. 5 is the smallest value n will take on. Example 2:  Input: n = 3 Output: 3 Explanation: Initially, n = 3. 3 is the smallest value n will take on.    Constraints:  2 <= n <= 105", Medium
2508,"There is an undirected graph consisting of n nodes numbered from 1 to n. You are given the integer n and a 2D array edges where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi. The graph can be disconnected.  You can add at most two additional edges (possibly none) to this graph so that there are no repeated edges and no self-loops.  Return true if it is possible to make the degree of each node in the graph even, otherwise return false.  The degree of a node is the number of edges connected to it.     Example 1:   Input: n = 5, edges = [[1,2],[2,3],[3,4],[4,2],[1,4],[2,5]] Output: true Explanation: The above diagram shows a valid way of adding an edge. Every node in the resulting graph is connected to an even number of edges. Example 2:   Input: n = 4, edges = [[1,2],[3,4]] Output: true Explanation: The above diagram shows a valid way of adding two edges. Example 3:   Input: n = 4, edges = [[1,2],[1,3],[1,4]] Output: false Explanation: It is not possible to obtain a valid graph with adding at most 2 edges.    Constraints:  3 <= n <= 105 2 <= edges.length <= 105 edges[i].length == 2 1 <= ai, bi <= n ai != bi There are no repeated edges.", Hard
2509,"You are given an integer n. There is a complete binary tree with 2n - 1 nodes. The root of that tree is the node with the value 1, and every node with a value val in the range [1, 2n - 1 - 1] has two children where:  The left node has the value 2 * val, and The right node has the value 2 * val + 1. You are also given a 2D integer array queries of length m, where queries[i] = [ai, bi]. For each query, solve the following problem:  Add an edge between the nodes with values ai and bi. Find the length of the cycle in the graph. Remove the added edge between nodes with values ai and bi. Note that:  A cycle is a path that starts and ends at the same node, and each edge in the path is visited only once. The length of a cycle is the number of edges visited in the cycle. There could be multiple edges between two nodes in the tree after adding the edge of the query. Return an array answer of length m where answer[i] is the answer to the ith query.     Example 1:   Input: n = 3, queries = [[5,3],[4,7],[2,3]] Output: [4,5,3] Explanation: The diagrams above show the tree of 23 - 1 nodes. Nodes colored in red describe the nodes in the cycle after adding the edge. - After adding the edge between nodes 3 and 5, the graph contains a cycle of nodes [5,2,1,3]. Thus answer to the first query is 4. We delete the added edge and process the next query. - After adding the edge between nodes 4 and 7, the graph contains a cycle of nodes [4,2,1,3,7]. Thus answer to the second query is 5. We delete the added edge and process the next query. - After adding the edge between nodes 2 and 3, the graph contains a cycle of nodes [2,1,3]. Thus answer to the third query is 3. We delete the added edge. Example 2:   Input: n = 2, queries = [[1,2]] Output: [2] Explanation: The diagram above shows the tree of 22 - 1 nodes. Nodes colored in red describe the nodes in the cycle after adding the edge. - After adding the edge between nodes 1 and 2, the graph contains a cycle of nodes [2,1]. Thus answer for the first query is 2. We delete the added edge.    Constraints:  2 <= n <= 30 m == queries.length 1 <= m <= 105 queries[i].length == 2 1 <= ai, bi <= 2n - 1 ai != bi", Hard
2511,"You are given a 0-indexed integer array forts of length n representing the positions of several forts. forts[i] can be -1, 0, or 1 where:  -1 represents there is no fort at the ith position. 0 indicates there is an enemy fort at the ith position. 1 indicates the fort at the ith the position is under your command. Now you have decided to move your army from one of your forts at position i to an empty position j such that:  0 <= i, j <= n - 1 The army travels over enemy forts only. Formally, for all k where min(i,j) < k < max(i,j), forts[k] == 0. While moving the army, all the enemy forts that come in the way are captured.  Return the maximum number of enemy forts that can be captured. In case it is impossible to move your army, or you do not have any fort under your command, return 0.     Example 1:  Input: forts = [1,0,0,-1,0,0,0,0,1] Output: 4 Explanation: - Moving the army from position 0 to position 3 captures 2 enemy forts, at 1 and 2. - Moving the army from position 8 to position 3 captures 4 enemy forts. Since 4 is the maximum number of enemy forts that can be captured, we return 4. Example 2:  Input: forts = [0,0,1,-1] Output: 0 Explanation: Since no enemy fort can be captured, 0 is returned.    Constraints:  1 <= forts.length <= 1000 -1 <= forts[i] <= 1", Easy
2512,"You are given two string arrays positive_feedback and negative_feedback, containing the words denoting positive and negative feedback, respectively. Note that no word is both positive and negative.  Initially every student has 0 points. Each positive word in a feedback report increases the points of a student by 3, whereas each negative word decreases the points by 1.  You are given n feedback reports, represented by a 0-indexed string array report and a 0-indexed integer array student_id, where student_id[i] represents the ID of the student who has received the feedback report report[i]. The ID of each student is unique.  Given an integer k, return the top k students after ranking them in non-increasing order by their points. In case more than one student has the same points, the one with the lower ID ranks higher.     Example 1:  Input: positive_feedback = [""smart"",""brilliant"",""studious""], negative_feedback = [""not""], report = [""this student is studious"",""the student is smart""], student_id = [1,2], k = 2 Output: [1,2] Explanation:  Both the students have 1 positive feedback and 3 points but since student 1 has a lower ID he ranks higher. Example 2:  Input: positive_feedback = [""smart"",""brilliant"",""studious""], negative_feedback = [""not""], report = [""this student is not studious"",""the student is smart""], student_id = [1,2], k = 2 Output: [2,1] Explanation:  - The student with ID 1 has 1 positive feedback and 1 negative feedback, so he has 3-1=2 points.  - The student with ID 2 has 1 positive feedback, so he has 3 points.  Since student 2 has more points, [2,1] is returned.    Constraints:  1 <= positive_feedback.length, negative_feedback.length <= 104 1 <= positive_feedback[i].length, negative_feedback[j].length <= 100 Both positive_feedback[i] and negative_feedback[j] consists of lowercase English letters. No word is present in both positive_feedback and negative_feedback. n == report.length == student_id.length 1 <= n <= 104 report[i] consists of lowercase English letters and spaces ' '. There is a single space between consecutive words of report[i]. 1 <= report[i].length <= 100 1 <= student_id[i] <= 109 All the values of student_id[i] are unique. 1 <= k <= n", Medium
2513,"We have two arrays arr1 and arr2 which are initially empty. You need to add positive integers to them such that they satisfy all the following conditions:  arr1 contains uniqueCnt1 distinct positive integers, each of which is not divisible by divisor1. arr2 contains uniqueCnt2 distinct positive integers, each of which is not divisible by divisor2. No integer is present in both arr1 and arr2. Given divisor1, divisor2, uniqueCnt1, and uniqueCnt2, return the minimum possible maximum integer that can be present in either array.     Example 1:  Input: divisor1 = 2, divisor2 = 7, uniqueCnt1 = 1, uniqueCnt2 = 3 Output: 4 Explanation:  We can distribute the first 4 natural numbers into arr1 and arr2. arr1 = [1] and arr2 = [2,3,4]. We can see that both arrays satisfy all the conditions. Since the maximum value is 4, we return it. Example 2:  Input: divisor1 = 3, divisor2 = 5, uniqueCnt1 = 2, uniqueCnt2 = 1 Output: 3 Explanation:  Here arr1 = [1,2], and arr2 = [3] satisfy all conditions. Since the maximum value is 3, we return it. Example 3:  Input: divisor1 = 2, divisor2 = 4, uniqueCnt1 = 8, uniqueCnt2 = 2 Output: 15 Explanation:  Here, the final possible arrays can be arr1 = [1,3,5,7,9,11,13,15], and arr2 = [2,6]. It can be shown that it is not possible to obtain a lower maximum satisfying all conditions.     Constraints:  2 <= divisor1, divisor2 <= 105 1 <= uniqueCnt1, uniqueCnt2 < 109 2 <= uniqueCnt1 + uniqueCnt2 <= 109", Medium
2514,"You are given a string s containing one or more words. Every consecutive pair of words is separated by a single space ' '.  A string t is an anagram of string s if the ith word of t is a permutation of the ith word of s.  For example, ""acb dfe"" is an anagram of ""abc def"", but ""def cab"" and ""adc bef"" are not. Return the number of distinct anagrams of s. Since the answer may be very large, return it modulo 109 + 7.     Example 1:  Input: s = ""too hot"" Output: 18 Explanation: Some of the anagrams of the given string are ""too hot"", ""oot hot"", ""oto toh"", ""too toh"", and ""too oht"". Example 2:  Input: s = ""aa"" Output: 1 Explanation: There is only one anagram possible for the given string.    Constraints:  1 <= s.length <= 105 s consists of lowercase English letters and spaces ' '. There is single space between consecutive words.", Hard
2515,"You are given a 0-indexed circular string array words and a string target. A circular array means that the array's end connects to the array's beginning.  Formally, the next element of words[i] is words[(i + 1) % n] and the previous element of words[i] is words[(i - 1 + n) % n], where n is the length of words. Starting from startIndex, you can move to either the next word or the previous word with 1 step at a time.  Return the shortest distance needed to reach the string target. If the string target does not exist in words, return -1.     Example 1:  Input: words = [""hello"",""i"",""am"",""leetcode"",""hello""], target = ""hello"", startIndex = 1 Output: 1 Explanation: We start from index 1 and can reach ""hello"" by - moving 3 units to the right to reach index 4. - moving 2 units to the left to reach index 4. - moving 4 units to the right to reach index 0. - moving 1 unit to the left to reach index 0. The shortest distance to reach ""hello"" is 1. Example 2:  Input: words = [""a"",""b"",""leetcode""], target = ""leetcode"", startIndex = 0 Output: 1 Explanation: We start from index 0 and can reach ""leetcode"" by - moving 2 units to the right to reach index 3. - moving 1 unit to the left to reach index 3. The shortest distance to reach ""leetcode"" is 1. Example 3:  Input: words = [""i"",""eat"",""leetcode""], target = ""ate"", startIndex = 0 Output: -1 Explanation: Since ""ate"" does not exist in words, we return -1.    Constraints:  1 <= words.length <= 100 1 <= words[i].length <= 100 words[i] and target consist of only lowercase English letters. 0 <= startIndex < words.length", Easy
2516,"You are given a string s consisting of the characters 'a', 'b', and 'c' and a non-negative integer k. Each minute, you may take either the leftmost character of s, or the rightmost character of s.  Return the minimum number of minutes needed for you to take at least k of each character, or return -1 if it is not possible to take k of each character.     Example 1:  Input: s = ""aabaaaacaabc"", k = 2 Output: 8 Explanation:  Take three characters from the left of s. You now have two 'a' characters, and one 'b' character. Take five characters from the right of s. You now have four 'a' characters, two 'b' characters, and two 'c' characters. A total of 3 + 5 = 8 minutes is needed. It can be proven that 8 is the minimum number of minutes needed. Example 2:  Input: s = ""a"", k = 1 Output: -1 Explanation: It is not possible to take one 'b' or 'c' so return -1.    Constraints:  1 <= s.length <= 105 s consists of only the letters 'a', 'b', and 'c'. 0 <= k <= s.length", Medium
2517,"You are given an array of positive integers price where price[i] denotes the price of the ith candy and a positive integer k.  The store sells baskets of k distinct candies. The tastiness of a candy basket is the smallest absolute difference of the prices of any two candies in the basket.  Return the maximum tastiness of a candy basket.     Example 1:  Input: price = [13,5,1,8,21,2], k = 3 Output: 8 Explanation: Choose the candies with the prices [13,5,21]. The tastiness of the candy basket is: min(|13 - 5|, |13 - 21|, |5 - 21|) = min(8, 8, 16) = 8. It can be proven that 8 is the maximum tastiness that can be achieved. Example 2:  Input: price = [1,3,1], k = 2 Output: 2 Explanation: Choose the candies with the prices [1,3]. The tastiness of the candy basket is: min(|1 - 3|) = min(2) = 2. It can be proven that 2 is the maximum tastiness that can be achieved. Example 3:  Input: price = [7,7,7,7], k = 2 Output: 0 Explanation: Choosing any two distinct candies from the candies we have will result in a tastiness of 0.    Constraints:  2 <= k <= price.length <= 105 1 <= price[i] <= 109", Medium
2518,"You are given an array nums consisting of positive integers and an integer k.  Partition the array into two ordered groups such that each element is in exactly one group. A partition is called great if the sum of elements of each group is greater than or equal to k.  Return the number of distinct great partitions. Since the answer may be too large, return it modulo 109 + 7.  Two partitions are considered distinct if some element nums[i] is in different groups in the two partitions.     Example 1:  Input: nums = [1,2,3,4], k = 4 Output: 6 Explanation: The great partitions are: ([1,2,3], [4]), ([1,3], [2,4]), ([1,4], [2,3]), ([2,3], [1,4]), ([2,4], [1,3]) and ([4], [1,2,3]). Example 2:  Input: nums = [3,3,3], k = 4 Output: 0 Explanation: There are no great partitions for this array. Example 3:  Input: nums = [6,6], k = 2 Output: 2 Explanation: We can either put nums[0] in the first partition or in the second partition. The great partitions will be ([6], [6]) and ([6], [6]).    Constraints:  1 <= nums.length, k <= 1000 1 <= nums[i] <= 109", Hard
2520,"Given an integer num, return the number of digits in num that divide num.  An integer val divides nums if nums % val == 0.     Example 1:  Input: num = 7 Output: 1 Explanation: 7 divides itself, hence the answer is 1. Example 2:  Input: num = 121 Output: 2 Explanation: 121 is divisible by 1, but not 2. Since 1 occurs twice as a digit, we return 2. Example 3:  Input: num = 1248 Output: 4 Explanation: 1248 is divisible by all of its digits, hence the answer is 4.    Constraints:  1 <= num <= 109 num does not contain 0 as one of its digits.", Easy
2521,"Given an array of positive integers nums, return the number of distinct prime factors in the product of the elements of nums.  Note that:  A number greater than 1 is called prime if it is divisible by only 1 and itself. An integer val1 is a factor of another integer val2 if val2 / val1 is an integer.    Example 1:  Input: nums = [2,4,3,7,10,6] Output: 4 Explanation: The product of all the elements in nums is: 2 * 4 * 3 * 7 * 10 * 6 = 10080 = 25 * 32 * 5 * 7. There are 4 distinct prime factors so we return 4. Example 2:  Input: nums = [2,4,8,16] Output: 1 Explanation: The product of all the elements in nums is: 2 * 4 * 8 * 16 = 1024 = 210. There is 1 distinct prime factor so we return 1.    Constraints:  1 <= nums.length <= 104 2 <= nums[i] <= 1000", Medium
2522,"You are given a string s consisting of digits from 1 to 9 and an integer k.  A partition of a string s is called good if:  Each digit of s is part of exactly one substring. The value of each substring is less than or equal to k. Return the minimum number of substrings in a good partition of s. If no good partition of s exists, return -1.  Note that:  The value of a string is its result when interpreted as an integer. For example, the value of ""123"" is 123 and the value of ""1"" is 1. A substring is a contiguous sequence of characters within a string.    Example 1:  Input: s = ""165462"", k = 60 Output: 4 Explanation: We can partition the string into substrings ""16"", ""54"", ""6"", and ""2"". Each substring has a value less than or equal to k = 60. It can be shown that we cannot partition the string into less than 4 substrings. Example 2:  Input: s = ""238182"", k = 5 Output: -1 Explanation: There is no good partition for this string.    Constraints:  1 <= s.length <= 105 s[i] is a digit from '1' to '9'. 1 <= k <= 109", Medium
2523,"Given two positive integers left and right, find the two integers num1 and num2 such that:  left <= nums1 < nums2 <= right . nums1 and nums2 are both prime numbers. nums2 - nums1 is the minimum amongst all other pairs satisfying the above conditions. Return the positive integer array ans = [nums1, nums2]. If there are multiple pairs satisfying these conditions, return the one with the minimum nums1 value or [-1, -1] if such numbers do not exist.  A number greater than 1 is called prime if it is only divisible by 1 and itself.     Example 1:  Input: left = 10, right = 19 Output: [11,13] Explanation: The prime numbers between 10 and 19 are 11, 13, 17, and 19. The closest gap between any pair is 2, which can be achieved by [11,13] or [17,19]. Since 11 is smaller than 17, we return the first pair. Example 2:  Input: left = 4, right = 6 Output: [-1,-1] Explanation: There exists only one prime number in the given range, so the conditions cannot be satisfied.    Constraints:  1 <= left <= right <= 106", Medium
2525,"Given four integers length, width, height, and mass, representing the dimensions and mass of a box, respectively, return a string representing the category of the box.  The box is ""Bulky"" if: Any of the dimensions of the box is greater or equal to 104. Or, the volume of the box is greater or equal to 109. If the mass of the box is greater or equal to 100, it is ""Heavy"". If the box is both ""Bulky"" and ""Heavy"", then its category is ""Both"". If the box is neither ""Bulky"" nor ""Heavy"", then its category is ""Neither"". If the box is ""Bulky"" but not ""Heavy"", then its category is ""Bulky"". If the box is ""Heavy"" but not ""Bulky"", then its category is ""Heavy"". Note that the volume of the box is the product of its length, width and height.     Example 1:  Input: length = 1000, width = 35, height = 700, mass = 300 Output: ""Heavy"" Explanation:  None of the dimensions of the box is greater or equal to 104.  Its volume = 24500000 <= 109. So it cannot be categorized as ""Bulky"". However mass >= 100, so the box is ""Heavy"". Since the box is not ""Bulky"" but ""Heavy"", we return ""Heavy"". Example 2:  Input: length = 200, width = 50, height = 800, mass = 50 Output: ""Neither"" Explanation:  None of the dimensions of the box is greater or equal to 104. Its volume = 8 * 106 <= 109. So it cannot be categorized as ""Bulky"". Its mass is also less than 100, so it cannot be categorized as ""Heavy"" either.  Since its neither of the two above categories, we return ""Neither"".    Constraints:  1 <= length, width, height <= 105 1 <= mass <= 103", Easy
2526,"For a stream of integers, implement a data structure that checks if the last k integers parsed in the stream are equal to value.  Implement the DataStream class:  DataStream(int value, int k) Initializes the object with an empty integer stream and the two integers value and k. boolean consec(int num) Adds num to the stream of integers. Returns true if the last k integers are equal to value, and false otherwise. If there are less than k integers, the condition does not hold true, so returns false.    Example 1:  Input [""DataStream"", ""consec"", ""consec"", ""consec"", ""consec""] [[4, 3], [4], [4], [4], [3]] Output [null, false, false, true, false]  Explanation DataStream dataStream = new DataStream(4, 3); //value = 4, k = 3  dataStream.consec(4); // Only 1 integer is parsed, so returns False.  dataStream.consec(4); // Only 2 integers are parsed.                       // Since 2 is less than k, returns False.  dataStream.consec(4); // The 3 integers parsed are all equal to value, so returns True.  dataStream.consec(3); // The last k integers parsed in the stream are [4,4,3].                       // Since 3 is not equal to value, it returns False.    Constraints:  1 <= value, num <= 109 1 <= k <= 105 At most 105 calls will be made to consec.", Medium
2527,"You are given a 0-indexed integer array nums.  The effective value of three indices i, j, and k is defined as ((nums[i] | nums[j]) & nums[k]).  The xor-beauty of the array is the XORing of the effective values of all the possible triplets of indices (i, j, k) where 0 <= i, j, k < n.  Return the xor-beauty of nums.  Note that:  val1 | val2 is bitwise OR of val1 and val2. val1 & val2 is bitwise AND of val1 and val2.    Example 1:  Input: nums = [1,4] Output: 5 Explanation:  The triplets and their corresponding effective values are listed below: - (0,0,0) with effective value ((1 | 1) & 1) = 1 - (0,0,1) with effective value ((1 | 1) & 4) = 0 - (0,1,0) with effective value ((1 | 4) & 1) = 1 - (0,1,1) with effective value ((1 | 4) & 4) = 4 - (1,0,0) with effective value ((4 | 1) & 1) = 1 - (1,0,1) with effective value ((4 | 1) & 4) = 4 - (1,1,0) with effective value ((4 | 4) & 1) = 0 - (1,1,1) with effective value ((4 | 4) & 4) = 4  Xor-beauty of array will be bitwise XOR of all beauties = 1 ^ 0 ^ 1 ^ 4 ^ 1 ^ 4 ^ 0 ^ 4 = 5. Example 2:  Input: nums = [15,45,20,2,34,35,5,44,32,30] Output: 34 Explanation: The xor-beauty of the given array is 34.    Constraints:  1 <= nums.length <= 105 1 <= nums[i] <= 109", Medium
2528,"You are given a 0-indexed integer array stations of length n, where stations[i] represents the number of power stations in the ith city.  Each power station can provide power to every city in a fixed range. In other words, if the range is denoted by r, then a power station at city i can provide power to all cities j such that |i - j| <= r and 0 <= i, j <= n - 1.  Note that |x| denotes absolute value. For example, |7 - 5| = 2 and |3 - 10| = 7. The power of a city is the total number of power stations it is being provided power from.  The government has sanctioned building k more power stations, each of which can be built in any city, and have the same range as the pre-existing ones.  Given the two integers r and k, return the maximum possible minimum power of a city, if the additional power stations are built optimally.  Note that you can build the k power stations in multiple cities.     Example 1:  Input: stations = [1,2,4,5,0], r = 1, k = 2 Output: 5 Explanation:  One of the optimal ways is to install both the power stations at city 1.  So stations will become [1,4,4,5,0]. - City 0 is provided by 1 + 4 = 5 power stations. - City 1 is provided by 1 + 4 + 4 = 9 power stations. - City 2 is provided by 4 + 4 + 5 = 13 power stations. - City 3 is provided by 5 + 4 = 9 power stations. - City 4 is provided by 5 + 0 = 5 power stations. So the minimum power of a city is 5. Since it is not possible to obtain a larger power, we return 5. Example 2:  Input: stations = [4,4,4,4], r = 0, k = 3 Output: 4 Explanation:  It can be proved that we cannot make the minimum power of a city greater than 4.    Constraints:  n == stations.length 1 <= n <= 105 0 <= stations[i] <= 105 0 <= r <= n - 1 0 <= k <= 109", Hard
2529,"Given an array nums sorted in non-decreasing order, return the maximum between the number of positive integers and the number of negative integers.  In other words, if the number of positive integers in nums is pos and the number of negative integers is neg, then return the maximum of pos and neg. Note that 0 is neither positive nor negative.     Example 1:  Input: nums = [-2,-1,-1,1,2,3] Output: 3 Explanation: There are 3 positive integers and 3 negative integers. The maximum count among them is 3. Example 2:  Input: nums = [-3,-2,-1,0,0,1,2] Output: 3 Explanation: There are 2 positive integers and 3 negative integers. The maximum count among them is 3. Example 3:  Input: nums = [5,20,66,1314] Output: 4 Explanation: There are 4 positive integers and 0 negative integers. The maximum count among them is 4.    Constraints:  1 <= nums.length <= 2000 -2000 <= nums[i] <= 2000 nums is sorted in a non-decreasing order.    Follow up: Can you solve the problem in O(log(n)) time complexity?", Easy
2530,"You are given a 0-indexed integer array nums and an integer k. You have a starting score of 0.  In one operation:  choose an index i such that 0 <= i < nums.length, increase your score by nums[i], and replace nums[i] with ceil(nums[i] / 3). Return the maximum possible score you can attain after applying exactly k operations.  The ceiling function ceil(val) is the least integer greater than or equal to val.     Example 1:  Input: nums = [10,10,10,10,10], k = 5 Output: 50 Explanation: Apply the operation to each array element exactly once. The final score is 10 + 10 + 10 + 10 + 10 = 50. Example 2:  Input: nums = [1,10,3,3,3], k = 3 Output: 17 Explanation: You can do the following operations: Operation 1: Select i = 1, so nums becomes [1,4,3,3,3]. Your score increases by 10. Operation 2: Select i = 1, so nums becomes [1,2,3,3,3]. Your score increases by 4. Operation 3: Select i = 2, so nums becomes [1,1,1,3,3]. Your score increases by 3. The final score is 10 + 4 + 3 = 17.    Constraints:  1 <= nums.length, k <= 105 1 <= nums[i] <= 109", Medium
2531,"You are given two 0-indexed strings word1 and word2.  A move consists of choosing two indices i and j such that 0 <= i < word1.length and 0 <= j < word2.length and swapping word1[i] with word2[j].  Return true if it is possible to get the number of distinct characters in word1 and word2 to be equal with exactly one move. Return false otherwise.     Example 1:  Input: word1 = ""ac"", word2 = ""b"" Output: false Explanation: Any pair of swaps would yield two distinct characters in the first string, and one in the second string. Example 2:  Input: word1 = ""abcc"", word2 = ""aab"" Output: true Explanation: We swap index 2 of the first string with index 0 of the second string. The resulting strings are word1 = ""abac"" and word2 = ""cab"", which both have 3 distinct characters. Example 3:  Input: word1 = ""abcde"", word2 = ""fghij"" Output: true Explanation: Both resulting strings will have 5 distinct characters, regardless of which indices we swap.    Constraints:  1 <= word1.length, word2.length <= 105 word1 and word2 consist of only lowercase English letters.", Medium
2532,"There are k workers who want to move n boxes from an old warehouse to a new one. You are given the two integers n and k, and a 2D integer array time of size k x 4 where time[i] = [leftToRighti, pickOldi, rightToLefti, putNewi].  The warehouses are separated by a river and connected by a bridge. The old warehouse is on the right bank of the river, and the new warehouse is on the left bank of the river. Initially, all k workers are waiting on the left side of the bridge. To move the boxes, the ith worker (0-indexed) can :  Cross the bridge from the left bank (new warehouse) to the right bank (old warehouse) in leftToRighti minutes. Pick a box from the old warehouse and return to the bridge in pickOldi minutes. Different workers can pick up their boxes simultaneously. Cross the bridge from the right bank (old warehouse) to the left bank (new warehouse) in rightToLefti minutes. Put the box in the new warehouse and return to the bridge in putNewi minutes. Different workers can put their boxes simultaneously. A worker i is less efficient than a worker j if either condition is met:  leftToRighti + rightToLefti > leftToRightj + rightToLeftj leftToRighti + rightToLefti == leftToRightj + rightToLeftj and i > j The following rules regulate the movement of the workers through the bridge :  If a worker x reaches the bridge while another worker y is crossing the bridge, x waits at their side of the bridge. If the bridge is free, the worker waiting on the right side of the bridge gets to cross the bridge. If more than one worker is waiting on the right side, the one with the lowest efficiency crosses first. If the bridge is free and no worker is waiting on the right side, and at least one box remains at the old warehouse, the worker on the left side of the river gets to cross the bridge. If more than one worker is waiting on the left side, the one with the lowest efficiency crosses first. Return the instance of time at which the last worker reaches the left bank of the river after all n boxes have been put in the new warehouse.     Example 1:  Input: n = 1, k = 3, time = [[1,1,2,1],[1,1,3,1],[1,1,4,1]] Output: 6 Explanation:  From 0 to 1: worker 2 crosses the bridge from the left bank to the right bank. From 1 to 2: worker 2 picks up a box from the old warehouse. From 2 to 6: worker 2 crosses the bridge from the right bank to the left bank. From 6 to 7: worker 2 puts a box at the new warehouse. The whole process ends after 7 minutes. We return 6 because the problem asks for the instance of time at which the last worker reaches the left bank. Example 2:  Input: n = 3, k = 2, time = [[1,9,1,8],[10,10,10,10]] Output: 50 Explanation:  From 0  to 10: worker 1 crosses the bridge from the left bank to the right bank. From 10 to 20: worker 1 picks up a box from the old warehouse. From 10 to 11: worker 0 crosses the bridge from the left bank to the right bank. From 11 to 20: worker 0 picks up a box from the old warehouse. From 20 to 30: worker 1 crosses the bridge from the right bank to the left bank. From 30 to 40: worker 1 puts a box at the new warehouse. From 30 to 31: worker 0 crosses the bridge from the right bank to the left bank. From 31 to 39: worker 0 puts a box at the new warehouse. From 39 to 40: worker 0 crosses the bridge from the left bank to the right bank. From 40 to 49: worker 0 picks up a box from the old warehouse. From 49 to 50: worker 0 crosses the bridge from the right bank to the left bank. From 50 to 58: worker 0 puts a box at the new warehouse. The whole process ends after 58 minutes. We return 50 because the problem asks for the instance of time at which the last worker reaches the left bank.    Constraints:  1 <= n, k <= 104 time.length == k time[i].length == 4 1 <= leftToRighti, pickOldi, rightToLefti, putNewi <= 1000", Hard